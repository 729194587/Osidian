什么叫：在一个x86-64系统中，对同一个目标模块中符号的引用是不需要特殊处理使之成为PIC。

**PIC（Position-Independent Code）**：  
👉 指的是**代码可以被加载到内存的任意地址上仍能正常运行**的代码。

这种代码常用于：

- **共享库（shared library, `.so`）**，因为共享库在不同进程里会被加载到不同地址。
- 或者编译器生成的动态链接可执行文件。

为了让代码可以这样运行，编译器需要确保：
- **不能使用绝对地址**
- **必须通过相对地址或表间接访问全局符号**
所以引入了
**GOT（Global Offset Table）**：
> 程序访问全局变量或函数时，不是直接跳转到固定地址，而是通过 GOT 找地址。

同一个模块的符号引用使用的是**RIP-relative addressing（基于指令指针的相对寻址）**，所以可以不用进行PIC处理。
例如：
```c
int x = 10;

int f() {
    return x + 1;
}
```
经过汇编后：
```c

  mov x(%rip), %eax   # 从RIP相对地址取x
  add $1, %eax
  ret
```
x和f在同一个文件。
如果x在别的共享库里：
```c
mov x@GOTPCREL(%rip), %rax
mov (%rax), %eax

```
编译器就会使用GOT来间接引用x。
以上是变量的GOT使用，对于函数引用，它会更复杂一些。需要GOT和PLT两个表来协调进行。
```c
extern void foo(void);
void f() { foo(); }

```

汇编：
```c
call foo@PLT
```

**重定位和PIC的区别：**
## 🧩 一、先回顾：什么是“重定位记录”？

编译器和链接器在生成可执行文件或共享库时，  
会在目标文件（`.o`）里留下一些“**重定位记录** (relocation entries)”：

👉 它的意思是：

> “这个地方（比如某条指令或全局变量）引用了某个符号（函数或变量），  
> 但我现在不知道它的最终地址，等链接或加载时再补上。”

这种方式依赖于动态链接器在加载时：

1. **找到目标符号的实际地址（如 `foo` 在共享库中）**；
2. **修改代码段中的指令或数据，把真实地址写进去。**
动态重定位，还是和目标符号的位置有关。

## ⚙️ 二、位置无关代码（PIC）要解决的核心问题

**PIC 的目标：**

> 让代码在被加载到内存的任意位置时都能运行，  
> 不需要修改 `.text`（代码段）的内容。

也就是说，**加载时不需要对代码段做重定位。**

因为：

- 共享库通常会被多个进程同时映射；
- 如果加载时要修改代码（重定位），那每个进程都得有一份独立副本；
- 而 PIC 代码就可以让多个进程共享同一份 `.text` 段（只读映射）。

PIC在加载时比重定位快，但在运行时可能稍微慢一些，因为多了一次查GOT表。但总体来说还是PIC更优秀。

**延迟绑定：程序在第一次真正使用某个外部符号（函数或变量）时，才去解析它的真实地址**。  
而不是在程序加载阶段就把所有符号都解析完。以加快函数的启动时间。

**PLT和GOT的协作：**
先查PLT表，而PLT表的第一条指令是跳转到GOT表。
而GOT表先指向PLT的第二条指令。
PLT第二条指令把符号压入栈，告诉动态链接器来解析哪个符号。
动态链接器解析完符号后更新GOT表项，跳转到函数的真正地址。


而第二次进行解析时，通过PLT表跳转到GOT，直接得知函数符号的地址。

计算机的很多优化都是建立在查表上。
**缓存是硬件级的查表；动态规划是算法级的查表；GOT/PLT 是链接级的查表。


