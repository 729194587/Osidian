9.1-9.3的内容基本上都是408里操作系统讲到的，页表、缺页、物理地址和虚拟地址转换。

虚拟内存可以简化链接和加载、代码和数据共享，以及应用程序的内存分配。

虚拟内存为进程提供独立的地址空间，可以让进程的内存映像都使用相同的格式。这种一致性简化了链接器的设计和实现。

有的时候需要进程来共享代码和数据，操作系统可以将不同进程中适当的虚拟页面映射到相同的物理页面，从而让多个进程共享这部分代码。

### **内存保护**
每个页表条目里会有三个许可位：**SUP、READ、WRITE。**

SUP为1表示进程必须运行在内核态下才能访问该页面。

在既使用虚拟内存又使用高速缓存的系统里，大多数都是选择物理寻址来访问高速缓存。

### Linux虚拟内存系统

Linux为每个进程维护了一个单独的虚拟地址空间。
这个虚拟空间分为了内核虚拟内存和进程虚拟内存两部分。

在Linux内核里，为每个进程都分配了一个**task_struct结构体**，用于记录进程运行时所需要的所有信息。
而task_struct里面有一个指针:
```c
struct mm_struct *mm;
```
**mm指向的是一个mm_struct结构体，它专门描述虚拟内存空间。**
例如: pgd指向第一级页表的基址，mmap指向一个vm_area_structs的链表。每个vm_area_structs都描述了当前虚拟地址空间的一个区域，表示一段虚拟地址范围，其权限，和映射目标。

Linux在进行缺页处理的时候，会把虚拟地址和vm_area_structs里面的信息进行比对，来检查地址是否合法。
而一个进程可以创建任意数量的新虚拟内存区域，这导致了vm_area_structs的链表长度可能会很大，顺序检索比对开销较大。**因此在实际中，Linux会使用某些字段构成一颗红黑树，在树上进行查找。**

### 9.8 内存映射

Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这叫内存映射。这样，
- 内核不再通过 `read()` / `write()` 复制数据；
- 而是直接让这段虚拟地址和磁盘文件的页建立映射关系。
这样，可以通过访问虚拟空间而访问文件，让存在磁盘上的文件I/O像在内存里面一样。
虚拟内存区域可以映射到两种类型的对象的一种，一种是普通文件，一种是匿名文件。

（1）普通文件
```c
int fd = open("data.txt", O_RDWR);
char *p = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
```
🔹 这里的虚拟内存区域：

- 对应 `data.txt` 文件的内容；
- 如果写入 `p`（且是 `MAP_SHARED`），会修改磁盘文件；
- 如果多个进程都 mmap 同一文件，它们共享同一物理页。

📦 常见用途：

- 加载可执行文件的代码段、数据段;
- 共享内存(多个进程映射同一个文件);
- 直接对文件做内存 I/O。

(2)匿名文件
```c
char *p = mmap(NULL, 4096, PROT_READ|PROT_WRITE,
               MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
```
这里并不对应磁盘上的某个文件，只是单纯的物理页。
🔹 特点：

- 不关联任何文件；
- 初始化时全是零；
- 内容存在于内存或 swap（交换区）中；
- 进程退出后自动释放。

📦 常见用途：

- 动态分配堆（malloc 最终就是通过匿名 mmap 实现的）；
- 栈空间；
- 线程的栈；
- 进程之间的匿名共享内存（通过 `fork()` 继承）。
匿名映射不会写回磁盘。
虽然匿名映射不关联文件，但在内核中它仍然会对应一个特殊的内存对象结构（如匿名 inode），  
只是这个“文件”存在于内核中，不在磁盘上。  
这样做是为了统一管理：
> 所有映射，无论文件还是匿名，都能用相同的 `vm_area_struct` 和页表机制管理。



虚拟内存像不像是一种贷款？进程贷款自己拥有整片内存空间，等到需要用的时候它又急忙从磁盘那换过来。
页表（Page Table）就像是「贷款记录表」：
- 记录了哪些虚拟地址真的已经被兑现（对应物理页）；
- 哪些只是还在“账面上”（尚未分配）；
- 哪些“贷款已回收”（页被回收或换出）。

当进程访问一块没准备好的地址时：
> “这位客户要用钱了，但这笔钱现在银行（物理内存）没有。”

于是内核：
- 从磁盘文件或 swap 区取出数据；
- 把这笔“钱”暂时放进内存（发放贷款）；
- 修改页表，记录这次放款；
- 然后 CPU 再执行那条指令，就能正常访问了。

##  匿名映射 vs 文件映射 = 不同类型的贷款用途

|类型|类比|特点|
|---|---|---|
|文件映射（file-backed）|有抵押贷款（拿文件做抵押）|页的内容来自磁盘文件，可写回|
|匿名映射（anonymous）|无抵押贷款（凭空发钱）|页内容是零或 swap，不关联磁盘文件|

| 虚拟内存概念  | 类比    | 行为           |
| ------- | ----- | ------------ |
| 虚拟地址空间  | 信用额度  | 每个进程看似拥有巨额资源 |
| 页表      | 贷款合同  | 记录哪些页被兑现     |
| 缺页异常    | 贷款发放  | 访问触发分配或调入    |
| 页缓存     | 流动资金  | 提高访问速度       |
| 换页      | 贷款回收  | 收回暂不用的页      |
| swap 文件 | 银行备用金 | 存储被回收的页内容    |

每个进程都假设自己拥有整片内存空间，由于每个进程的虚拟地址是独立的，这样可以防止访存冲突。
每个进程的页表内容不一样，同一个虚拟地址转换后的物理内存也是不一样的。

#### 共享对象

虽然每个进程有自己私有的虚拟地址空间，但是许多进程也有相同的只读代码区域。
例如，每个Linux shell程序bash的进程都有相同的代码区域。
一个对象可以作为私有对象或者共享对象映射到虚拟地址空间中。
由于对象的文件名是唯一的，内核很容易判断该对象是否已被映射，从而让后面映射该文件的进程的页表项指向同一个物理页面。

私有对象在映射时和共享对象是一样的，两个进程映射一个私有对象时，起初也是指向的同一片物理页面。私有对象会采取一种叫**写时复制**（copy-on-write）的技术进行映射。

在这两个进程里，对应的私有区域里都被标记为只读。
只要有一个进程试图写私有区域内的页面，就会触发一个保护故障。
故障处理程序注意到进程试图写私有的写时复制区域的页面，然后会在物理内存创建一个该页面的新副本，更新进程页表项目指向该副本，恢复可写权限。

##### 回顾fork函数

fork函数被当前进程调用时，内核为新进程创建了当前进程的mm_struct、vm_area_structs和页表的副本。把两个进程的每个页面都设为只读，将区域结构（vm_area_structs）都设置为写时复制。
当两个进程的任意进行写操作时，物理页面就会有丝分裂成俩。

##### 回顾execve函数

当运行在进程的程序执行execve调用：
```c
execve("a.out",NULL,NULL);
```
execve函数会用a.out程序**替换**当前程序，具体步骤如下：
- 删除已存在的用户区域。
- 映射私有区域。
- 映射共享区域。
- 设置PC。
所以当execve运行成功的时候，不会返回当前进程。


#### 虚拟内存映射文件和直接读取文件到内存的区别在哪？

> **内存映射不是为了更快读文件，而是让“文件 → 内存 → 程序运行”之间形成一个统一、透明、零拷贝的体系。  
> 它让文件内容看起来就像在内存里一样，并且让 OS 可以用 page fault 机制按需加载和共享页面，从而减少内存、减少复制、减少系统调用。**

内存映射解决的是一个非常深层的问题：
### ❗「如何让文件 I/O 与虚拟内存机制 **统一**？」

- 访问文件：像访问内存
- 缺页：自动从磁盘加载
- 多进程共享：自动省内存
- 不需多个系统调用：减少 overhead
- 支持非常大的文件：用少量实际内存处理

read是程序员调用的，主动决定读取。
mmap是操作系统来决定，按需分页。

mmap还能让多个进程映射同一片物理页。
mmap不需要从内核缓冲区复制到你的用户缓冲区  
read 需要 copy 一份