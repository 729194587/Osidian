
垃圾收集器用于释放程序不再需要的已分配内存块。

垃圾收集器将内存视为一张**有向可达图**：

节点分为一组根节点和一组堆节点。
每个堆节点对应于堆中的一个已分配块。
有向边p->q意味着块p中的某个位置指向块q的某个位置。
每个根节点包含着指向堆的指针。
![[有向可达图.png]]

Java语言对使用指针有严格控制，能精确表示有向可达图，所有可以回收所有垃圾。
C通常不能精确表示。

#### Mark&Sweep垃圾收集器

Mark阶段会标记出根节点的所有可达和已分配的后继，使用的是块头部中空闲低位的某一位。
Sweep会清除掉所有的标记，回收未被标记的块。

为什么C不能精确表示？

C语言不会用类型信息来标记内存位置。它无法分辨一个参数是不是指针。

## 9.11 常见的和内存有关错误

间接引用坏指针。
```c
scanf("%d",val);
```
读取未初始化的内存

使用gets函数导致栈缓冲区溢出

假设指针和它们指向的对象的大小一样

错位
```c
int **A=(int**)Malloc(n*sizeof(int*));

for(int i=0;i<=n;i++)
A[i]=(int*)Malloc(m*sizeof(int));
```

内存泄漏
```c
void leak(int n)
{
int *x=(int *) Malloc(n*sizeof(int));
return;
}
```
x未被释放，变成了堆上的垃圾。经常调用leak会导致垃圾堆满整个虚拟地址空间。
对于守护进程和服务器这样的程序来说十分严重。
