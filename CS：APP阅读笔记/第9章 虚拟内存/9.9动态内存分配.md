#### mmap函数

```c
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags,
           int fd, off_t offset);
```
mmap函数会让内核创建一个新的虚拟内存区域，最好从地址addr开始，把文件描述符fd指定对象的连续的片映射到该区域。length是映射长度，offset是从文件开始出的偏移量开始映射。
prot表示区域的访问权限、flag指明是私有还是共享。

munmap函数则是删除一片虚拟空间。

动态内存分配器用于维护一个进程的虚拟内存区域----堆。对于每个进程，内核维护着一个变量brk，指向堆的顶部。

#### 为什么要用动态内存分配？

程序使用动态内存分配的重要原因是：经常直到程序实际运行时，才知道某些数据结构的大小。

例如：假设需要读入一个n个整数的链表，输入是n和接下来的n个整数。你可以静态定义这个数组，其最大数组大小是硬编码的：

```c
#define MAXN 15213

int array[MAXN];
int main()
{
int i,n;
scanf("%d",&n);
if(n>MAXN)
app_error("n的值太大")；
for(i=0;i<n;i++)
scanf("%d",&array[i]);
exit(0);
}
```

但是这样会比较机械，你想读取一个比MAXN还大的数组的话，只能使用一个更大的MAXN的值。
这在大型软件产品中是不可行的。

所以可以采用动态内存分配：
```c
int main()
{
int *array,i,n;

scanf("%d",&n);
array=(int*)Malloc(n*sizeof(int));
for(i=0;i<n;i++)
scanf("%d",&array[i]);
free(array);
exit(0);
}
```
分配器分为两种：
（1）**显示分配器**：要求应用显示地释放任何已分配的块。
C语言的malloc函数分配的内存需要通过free释放。
C++的new和delete也是这样。

（2）**隐式分配器**：又称垃圾收集器，要求分配器检测一个已分配的块何时不再被程序所使用，就释放这个块。自动释放的未使用的已分配块的过程叫垃圾收集。
Java、Lisp、ML之类的高级语言通过垃圾收集释放块。

malloc不初始化分配内存。
calloc初始化为0。
realloc可以改变已分配内存大小。

动态内存分配器可以通过使用mmap和munmap函数来分配和释放内存，也可以使用sbrk函数。
```c
#include<unistd.h>
void *sbrk(intptr_t incr);
```
sbrk通过操作brk指针来扩展和收缩堆。

造成堆利用率低的原因是碎片。

外部碎片：能支持分配的空闲块是不连续的。外部碎片难以量化且不能预测，分配器通常采用启发式策略来维持少量的大空闲块。

#### 边界标记：
边界标记法（Boundary Tag Method）是经典的堆内存管理技术，用来**快速合并相邻空闲块**，避免外部碎片。

每个堆块（block）都有：

1. **头部（Header）**
    - 记录块大小 + 是否已分配（allocated/free）
2. **尾部（Footer，也叫尾标记 Boundary Tag）**
    - 和头部一样，记录块大小 + 状态

> 有了头和尾的信息，不仅知道自己块的大小，也能快速找到前一个和后一个块，判断是否空闲。

当释放一个块时：

1. 查看 **前一个块** 和 **后一个块** 是否空闲。
    - 前块：通过当前块的头部和前块的尾部边界标记找到
    - 后块：通过当前块的头部和大小找到
2. 如果相邻块是空闲的，就把它们合并成一个更大的空闲块。
    - 更新新的 **头部和尾部** 为合并后的总大小
3. 如果前后块都已分配，则无需合并，直接标记自己为 free。

malloc函数在分配的时候需要对齐，C 标准规定：

> malloc 返回的指针必须适合存放任意内置类型的对象。

因此，malloc返回的地址是8字节（32字节）或者16字节（64位）对齐的。

堆管理器在分配内存时，通常会进行如下操作：

1. **将用户请求的大小向上取整到对齐边界**
2. **堆块的头部（Header）本身也对齐**

#### 显式空闲链表

在最基础的堆分配器中（隐式空闲链表 _implicit free list_）：
- 所有块（已分配 + 空闲）按顺序放在堆里；
- 查找空闲块时只能顺序扫描整个堆；
- 查找效率 = **O(n)**。
效率较慢，所以出现了显式空闲链表，只把空闲块串起来，节省查找时间。

在每个空闲块中，用一部分空间保存 **前驱指针（pred）** 和 **后继指针（succ）**，  
把所有空闲块组成一个双向链表。

但是，显式空闲链表也只是把复杂度降到了和空闲块的大小有关的地步，空闲块很多时仍然较慢。
于是，出现了分离的空闲链表。
#### 🚀 核心思想：按大小分组

> “分离空闲链表” = 建立**多条链表**，每条链表管理一类大小范围的空闲块。

分离存储策略：
（1）简单分离存储：
每个链表包含空闲块的大小的是一个大小区间的最大值。
但是容易造成碎片。
（2）分离适配：
每个链表的空闲块大小是一个范围。

伙伴系统是分离适配的特例，每个区间都是2的幂。




