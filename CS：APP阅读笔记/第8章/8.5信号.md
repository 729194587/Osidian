###### 硬件和软件如何合作提供基本的低层异常机制？

硬件负责检测异常和查表，跳转到异常处理程序--软件提供的具体异常处理逻辑。
Linux信号是一种消息，用于告诉进程发生了异常。进程在接收到信号后会通过控制转移来进入到信号处理程序，感觉和异常处理很像。
但是信号的**触发点**和异常不同，键盘的键入会触发信号、子进程的退出也会触发信号。
而且信号是由用户进程来处理的。

异常由cpu直接通知内核，而信号是内核通知用户进程。

Unix系统发送信号的机制是基于**进程组**这个概念的。

```
linux> /bin/kill -9 1234
```
发送信号9给进程1234，如果pid是负的，则会发给进程组为|pid|的所有进程。
```
linux> /bin/kill -9 -1234
```
进程也是通过kill函数来发送信号给其他进程的（包括它自己）。
此外，进程还可以调用alarm函数来给自己发定时器信号。

#### 编写信号处理程序

信号处理程序和主程序以及其他信号处理程序是并发运行的，因此需要遵守一些原则来保证这些并发在安全运行。

**原则1：处理程序要尽可能简单。**
**原则2：在处理程序中只调用异步信号安全的函数。**
**原则3：保存和恢复errno。**
**原则4：阻塞所有信号，保护对共享全局数据结构的访问。**
**原则5：用volatile声明全局变量。**
**原则6：用sig_atomic_t声明标志。**

这些规则是保守的，并非严格必需。

异步信号安全函数(**Async-signal-safe functions**):**可重入；或是不能被信号处理程序中断。**

##### 为什么信号处理程序只能用异步信号安全函数？
信号是异步发生的，可能会在任何时候打断代码的运行。
假如
```c
printf("Hello");
```
执行到一半，还没把hello放入到缓冲区时，
信号突然到来，程序跳转到信号处理函数执行。
这时，可能会出现**重入问题：函数在前一次调用还没完成时，又被第二次调用。**

- 主程序调用 `printf()` → `stdout` 正在被修改；
- 此时信号到来 → 跳转到信号处理函数；
- 信号处理函数里又调用了 `printf()`；
- 两次 `printf()` 同时访问全局缓冲区，**破坏内部状态**。
结果可能是：
- 死锁（内部互斥锁未释放）；
- 崩溃（写入非法地址）；
- 输出混乱（缓冲区被破坏）。

在信号处理程序中，产生输出的安全函数只有write，printf和sprintf都是不安全的。

```c
volatile int g;
```
volatile限定符强迫编译器每次在代码中引用g时，都要从内存中读取g的值。

信号的一个特点是不排队。pending位向量中，每个类型的信号只对应一位，这意味着每种类型最多有一个未处理的信号。两个相同类型的信号发送给一个进程时，第二个信号会被丢弃。

通常使用sigprocmask函数来阻塞一些信号，同步进程。

C++和Java提供的异常处理较为高级，是setjmp和longjmp的较为结构化版本。
try语句的catch语句类似于setjmp，throw语句类似于longjmp。

setjmp调用一次，返回两次。
longjmp调用一次，从不返回。
fork调用一次，返回两次。
execve调用一次，从不返回。