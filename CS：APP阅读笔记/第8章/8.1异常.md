（1）什么是：一个程序可以通过回避通常的栈规则，并执行到其他函数的任意位置的非本地跳转来对错误做出反应？

这个描述其实讲的是 **“非本地跳转（nonlocal jump）”** ——  C 语言中一种 **绕过正常函数调用栈规则** 的控制流机制，用来在程序某处（比如发生错误时）**跳回**到之前设定的“恢复点”。
正常情况下，函数的调用是利用栈来实现的
```c
main() → A() → B() → C()
```
需要按照后进先出返回
C → B → A → main

“非本地跳转”允许程序：

> **直接从深层函数跳回到之前某个指定函数的位置**，  
> 而不用按照正常的“函数返回”顺序层层退栈。

在 C 语言中，这种机制由：

- `setjmp()`（设置跳转点）
    
- `longjmp()`（跳回该点）  
    实现。
    
程序在某个安全点调用：setjmp(buf);

- 保存当前的 CPU 寄存器状态、栈指针、程序计数器（PC）到 `buf`。
    
- 这个位置就叫“跳转点”。
若程序在之后的执行中遇到错误，调用longjmp(buf, 1)会：
- 直接恢复 `buf` 中保存的寄存器和栈状态；
    
- 让程序“跳回” `setjmp()` 所在的位置执行。

``
```c
#include <stdio.h>
#include <setjmp.h>

jmp_buf env;

void func2() {
    printf("func2: error occurred!\n");
    longjmp(env, 1);  // 非本地跳转
}

void func1() {
    printf("func1: calling func2\n");
    func2();
    printf("func1: never executed\n");
}

int main() {
    if (setjmp(env) == 0) {
        // 正常路径
        printf("main: calling func1\n");
        func1();
    } else {
        // 从 longjmp 回来
        printf("main: recovered from error!\n");
    }
    return 0;
}
```
`
输出会是：
```c
main: calling func1
func1: calling func2
func2: error occurred!
main: recovered from error!

```

可以看到，function1虽然正常调用，但是没有执行完。
程序在执行了if的第一个代码块后，又执行了第二个代码块。
longjmp把场景还原到了setjmp函数执行到最后返回的时候，只是修改了它的返回值。


在系统启动时，操作系统会分配并初始化一张异常跳转表。表的起始地址放在一个叫**异常表基址寄存器**中。

过程调用的返回地址通常是下一条指令。异常可以是当前指令，也可以是下一条指令。
异步异常（不是由指令的执行造成的异常）通常是下一条指令。

而且，异常处理时不仅仅压入返回地址，还有一些额外信息。
此外，如果控制由用户态转到内核态，信息由内核栈保存。

**异常类别：
（1）中断： 来自IO设备的信号。 异步   返回到下一条指令。
（2）陷阱：有意的异常                同步   返回到下一条指令。
（3）故障：潜在可恢复的错误      同步   可能返回到当前指令。
（4）终止：不可恢复的错误          同步   不会返回。**


在x86-64系统，系统调用是通过一条syscall的陷阱指令来调用的。所有到Linux系统调用的参数通过通用寄存器来传递。 %rax传递系统调用号。


# 8.2进程

run：强调触发做某件事。
execution：这件事真正被CPU执行。

run一次，但是可以执行很多次。

父进程通过调用fork（）来创建子进程，子进程获得与父进程所有打开文件描述符的副本。
```c
int main()

{

    pid_t pid;

    int x=1;

    pid=Fork();

    if(pid==0)

    {

        printf("child:x=%d\n",++x);

        exit(0);

    }

    printf("parent:x=%d\n",--x);

    exit(0);

}
```

这意味着，当父进程调用fork创建子进程后，子进程和父进程都会停留在pid=Fork（）；这一行后。 由于子进程和父进程的pid是不同的，所以下面的代码不仅会被执行两次，还会有不同的输出。
而且，父进程和子进程的执行是并发的，这两个打印可能有不同的顺序。

如果一个父进程终止，内核会让**init进程**成为它子进程的养父。
init进程的PID是1，不会终止，是所有进程的祖先。

一个进程会调用waitpid（）函数来等待其子进程的终止。返回的是终止的进程的pid。

可以通过画进程图来理清程序创立子进程后的执行顺序。
**waitpid**函数会在子进程执行后。

**sleep**函数会让进程挂起一段时间，返回的是还剩下的休眠秒数。

**execve**函数可以让进程中运行一段新的程序，而且不会返回到原来的代码。

在操作系统中，fork和execve似乎经常成对出现：
```c
pid_t pid = fork();
if (pid == 0) {
    // 子进程
    execve("/bin/ls", argv, envp);  // 运行 ls 程序
}
else {
    // 父进程
    waitpid(pid, NULL, 0);  // 等待子进程结束
}
```

shell的main函数和execve函数关系密切,下面是大致的过程：
```c
int main() {
    char cmdline[1024];
    while (1) {
        printf("shell> ");           // 打印提示符
        fgets(cmdline, sizeof(cmdline), stdin); // 读取用户输入

        pid_t pid = fork();           // 创建子进程
        if (pid == 0) {
            // 子进程：执行命令
            execve(cmdline, argv, envp);   // 用用户输入的命令替换自己
            perror("execve failed");       // execve 出错才会执行到这里
            exit(1);
        } else {
            // 父进程：等待子进程结束
            waitpid(pid, NULL, 0);
        }
    }
}

```
shell读取用户输入的命令，判断是否是内置的命令，或者是否是可执行目标文件。

shell会通过调用parseline函数来对命令行进行解析，把它拆分成参数数组，以方便传入execve函数执行。

```c
while (1) {
    cmdline = readline("shell> ");   // 读取用户命令
    bg = parseline(cmdline, argv);   // 👈 拆分命令行
    pid = fork();                    // 创建子进程
    if (pid == 0) {
        execve(argv[0], argv, environ); // 执行命令
    }
    if (!bg)
        waitpid(pid, NULL, 0);       // 前台任务等待结束
}
```

