
### Unix IO

老是不太习惯C++的重载操作符<<(输入)>>(输出)。

Linux系统中，通过使用内核提供的系统级UnixI/O函数来实现较高级别的IO函数。

在Linux中，万物皆文件，所有的I/O设备都被模型化为文件，输入输出都被视作对相应文件的读和写。内核只把文件看作字节序列。

#### 打开文件
一个应用程序通过内核打开相应文件，内核会返回一个小非负整数，即该文件的描述符，在后续操作中标识该文件。内核记录打开文件的所有信息，应用程序记住描述符。

Linux shell 创建的每个进程开始时都有**三个打开文件：标准输入（描述符为0）、标准输出（1）、标准错误（2）。**

头文件
```c 
<unistd.h>
```
定义了常量 **STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO**,可以代替显式的描述符值。

#### 关闭文件
关闭文件时，内核释放文件打开时创建的数据结构，把描述符恢复到可用的描述符池中。
进程终止时，内核会关闭所有打开的文件释放内存资源。

### 10.2 文件

Linux文本文件由多行组成，一行由字符序列和"\n"结束。

**目录**是包含一组链接的文件。每个链接都把一个文件名映射到文件。
每个目录包含至少两个条目：“.”是到该目录的=自身的链接，".."是到目录层次结构中父目录的链接。

在 Linux 中：
- **文件名不属于文件自身**
- 文件内容和文件名是分离的结构

文件的实际内容与元数据放在**inode**里。  
而目录（directory）其实就是一个 **特殊的文件**，里面存储着一组 **(文件名，inode号)**。
因此：
> **目录 = 一张表（文件名 → inode号）**

'.'指向自身的inode，'..'指向父目录的inode。

套接字是用于和另一个进程进行跨网络通信的文件。

Linux内核把所有文件组织成一个**目录层次结构**，由名为/的根目录确定。

每个进程都有一个当前工作目录来确定其在目录层次结构中的当前位置。

### 10.3 打开和关闭文件

进程调用open函数来打开一个文件或创建一个新文件。
```c
#incldue<sys/types.h>
#incldue<sys/types.h>
#incldue<fcntl.h>

int open(char *filename,int flags,model_t mode);//成功返回新文件描述符，失败返回-1.

fd=Open("foot.txt",O_WRONLY|O_APPEND,O);
```
flag表示进程访问方式。
mode参数指定新文件的访问权限位。
每个进程都有一个umask，通过umask函数来设置。进程用带mode的open创建新文件时，文件访问权限被设置为mode&~ umask。

open函数返回的描述符总是进程中当前没有打开的最小描述符。
```c
#include<csapp.h>
int main()
{
int fd1,fd2;
fd1=Open("foo.txt",O_RDONLY,0);
Close(fd1);
fd2=Open("baz.txt",O_RDONLY,0);
printf("%d",fd2);
exit(0);
}
```
Unix进程生命周期开始时，打开的描述符赋值给了stdin(描述符0)、stdout(1)、stderr(2),所以第一次调用Open会返回3，调用close会释放掉。

close用于关闭文件。

#### 读和写文件

应用程序分别调用read和write来输入输出。
```c
#include<unistd.h>
ssize_t read(int fd, void *buf,size_t n);
ssize_t write(int fd, const void *buf,size_t n);
```
read 复制fd的文件的n个字节到buf，返回值-1会代表一个错误，返回值0则表示EOF，其他的返回值代表实际传送的字节数量。
write从buf复制最多n个字节到fd的文件位置。

返回值ssize_t和参数size_t的区别：
size_t是unsigned long 型，ssize_t是long型，read会返回-1，这导致需要是有符号数。

在一些情况下，read和write传送的字节比应用程序要求的要少，记作不足值（short count）。
- 读时遇到EOF。如果一个文件只有20字节，而我们要求读50字节，read就会返回0发出EOF信号。
- 从终端读文本行。如果打开文件与终端相关（键盘、显示器），每个read函数会一次传送一个文本行，返回文本行大小。
- 读和写网络套接字。内部缓冲约束和较长的网络延迟会让函数返回不足值。对Linux管道调用read和write时，也会出现不足值。

#### RIO包（Robust I/O）
RIO包能自动处理上文的不足值。
它提供了两类函数：
- 无缓冲的输入输出函数。这类函数之间在内存和文件之间读数据，对于将二进制数据读写到网络和从网络读写二进制数据尤其有用。一定会读满写满n个字节。
- 带缓冲的输入函数。

#### RIO无缓冲输入输出函数

```c
#include<csapp.h>
ssize_t rio_readn(int fd,void *usrbuf,size_t n);
ssize_t rio_writen(int fd,void *usrbuf,size_t n);

```

read和write函数可能会被信号打断，这需要手动在循环里检测并重试。
而如果RIO函数被一个从应用信号处理程序的返回中断，那么每个函数都会自动重启read或write。

#### RIO带缓冲的输入函数

假设你想逐行读取一个大文件或网络数据，判断文本行的数量的话，一种方法是：
用`read()`一个一个字节读，判断换行符，但是

```c
char c;
while (read(fd, &c, 1) == 1) {
    putchar(c);
}
```
每次 `read()` 都只读一个字节，不光性能差，还会频繁触发**系统调用**（用户态 → 内核态），效率非常低。
而`rio_readlineb` 使用了一个缓冲区 `rio_buf[]`，一次性调用 `read()` 从内核读入 **一个块（比如 8KB）**，然后：
- 把读到的内容存放到用户态缓冲区；
- 接下来的调用中，从这个缓冲区逐字节消费；
- **当缓冲区用完时**，再调用一次 `read()` 填入新的数据。

`rio_readinitb`

```c
void rio_readinitb(rio_t *rp, int fd);
```
这是一个准备函数，用于“绑定”一个文件描述符 `fd` 到一个 RIO 读取结构 `rio_t` 上，并设置好内部状态。

`rio_readnb`
作用：从缓冲中读 _n_ 字节（最多 n）
```c
ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n);
```
和 `rio_readn` 区别是：它使用了内部缓冲，避免系统调用频繁触发。

`rio_readlineb`
```c
ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);
```
**按行读取文本**，如网络通信或 SHELL 命令行。

##### - 这些带缓冲的函数的调用不应和无缓冲的rio_readn函数交叉使用

**因为带缓冲和无缓冲的读函数都直接操作文件描述符（fd），但其中带缓冲的函数会先从内部缓冲区读取数据，而无缓冲的函数会直接从内核读。**  
交叉使用会导致读取顺序混乱，出现丢数据或者重复读数据的错误。

#### 读取文件元数据

应用程序能够调用stat和fstat函数来检索到关于文件的信息（也称元数据）。

```c
#include<unistd.h>
#include<sys/stat.h>

int stat(const char *filename,struct stat *buf);
int fstat(int fd,struct stat *buf);
```
stat是一个结构体，里面会保存文件的信息。

`st_mode`编码了文件访问许可位和文件类型、`st_size`包含了文件的字节数大小。

#### 读取目录
```c
#include<sys/types.h>
#include<dirent.h>

DIR *opendir(const char *name);
```
opendir返回指向目录流的指针，即目录列表。

```c
#include<dirent.h>
struct dirent *readdir(DIR *dirp);
```
readdir返回的是指向流 dirp中下一个目录项的指针。

```c
struct dirent{
ino_t d_ino;
char d_name[256];
};
```
readdir出错会返回NULL，设置errno。可以通过检查errno是否被修改来区分错误。
