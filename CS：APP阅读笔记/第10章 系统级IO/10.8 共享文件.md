
内核用三个相关的数据结构来打开文件：
##### **描述符表**：
每个进程都有自己的描述符表，表项由进程打开的文件描述符来索引。
每个打开的描述符表项会指向文件表的一个表项。

##### 打开文件表：
所有进程共享文件表。
文件表表项：当前文件位置、引用记数、一个指向v-node表中对应表项的指针。关闭一个描述符会减少相应的引用计数，归零后内核删除该表项。

##### v-node表：
每个表项包含stat结构的大多数信息。

open同一个文件两次会返回两个不同描述符，这两个描述符会通过两个打开文件表项共享一个文件。

父进程和子进程的描述符完全一样，这表示它们对文件的读写会互相影响。
如果子进程close（fd），父进程仍然可以用fd访问。

### 10.9 I/O重定向

```
linux> ls > foo.txt
```
shell加载和执行ls程序，将标准输出重定向到文件foo.txt。

I/O重定向的一种方式是使用dup2函数。
```c
#incldue<unistd.h>
int dup2(int oldfd,int newfd);
```
dup2函数复制描述符表的表项oldfd到newfd。

### 10.10 标准I/O

C语言定义了一组高级输入输出函数，称为标准I/O库。
标准I/O库把一个打开的文件模型化为一个流。
一个流是一个指向FILE类型的结构的指针。

在高级 I/O 中（即 `stdio.h` 提供的），我们不是直接操作文件描述符，而是用一个叫做 **`FILE *` 类型的指针**。这个指针指向一个叫做“文件流”的抽象结构。

这个结构体里封装了：

- 对应的“文件描述符”
- 一个**用户空间缓冲区**（比如 4KB 或 8KB 的缓冲）
- 缓冲区当前状态（读/写模式、剩余空间等）
- 错误标志、EOF 标志等
也就是说，**`FILE *` 是对文件描述符的高级封装，加了缓冲机制，提供更方便的 API，比如 `fgets`、`fprintf`、`fread` 等**。

### 10.11 使用哪些I/O函数？

标准I/O：
```c
fopen  fdopen  fread  fwrite
fscanf fprintf sscanf sprintf
fgets  fputs   fflush fseek
fclose
```
RIO函数：
```c
rio_readn   rio_writen   rio_readinitb
rio_readlineb            rio_readnb
```
Unix I/O函数：通过系统调用
```c
open  read  write
lseek stat  close
```

- **只要可能就用标准I/O。** 
- **不要使用scanf或rio_readlineb来读二进制文件。**
- **对网络套接字的I/O使用RIO函数。**

一些限制：
- 如果中间没有插入对fflush、fseek、fsetpos或者rewind的调用，一个输入函数不能跟在输出函数后面。 fflush函数清空和流有关的缓冲区，而后三个使用lseek函数来重置当前文件位置。
- 如果中间没有fseek、fsetpos、rewind的调用，输出函数后面也不能跟输入函数，除非该输入函数遇到一个文件结束。

在使用 C 标准库的流（`FILE*`）时：

- 每个 `FILE*` 流都有**自己的缓冲区**，可能是用于读，也可能是用于写
- 每个流维护**文件位置指针**，表示下一次读写的文件偏移
- 但是，如果**交替混用读和写**，就可能导致缓冲区内容和文件位置不一致，造成意外行为

所以标准规定了**输入（读）和输出（写）操作之间的衔接必须符合一定规则**。

这些限制导致了一个问题，因为对套接字使用lseek函数是非法的。**套接字不是一个可寻址（seekable）的文件对象**。对套接字调用 `lseek` 没有意义，也不被内核支持。**普通文件可以随机访问，有“位置”；套接字是数据流，没有位置，不能 seek**。

标准I/O和系统级I/O的区别在于缓冲区。多次调用系统调用函数开销大，那就用缓冲区一次读多点。
RIO解决的核心问题就是由于信号中断导致的系统调用失败。

重定向
```
ls > output.txt
```
背后机制是：父进程 fork 一个子进程，并对 stdout 重定向到文件，然后 exec 执行 `ls`

标准I/O                    RIO             
		系统级IO
**底层简单可靠，高层方便易用**。