
套接字接口是一组函数，和UnixI/O函数组合起来，用以创建网络应用。

![[基于套接字接口的网络应用概述.png]]

IPv4的socket地址结构和通用的地址结构：
```c
/* IP socket address structure */
struct sockaddr_in {
    uint16_t       sin_family;   /* Protocol family (always AF_INET) */
    uint16_t       sin_port;     /* Port number in network byte order */
    struct in_addr sin_addr;     /* IP address in network byte order */
    unsigned char  sin_zero[8];  /* Pad to sizeof(struct sockaddr) */
};

/* Generic socket address structure (for connect, bind, and accept) */
struct sockaddr {
    uint16_t  sa_family;    /* Protocol family */
    char      sa_data[14];  /* Address data */
};
```

像 `bind()`、`connect()`、`accept()` 等网络接口函数，参数类型是 `struct sockaddr *`（通用类型），目的是为了支持不同类型的协议（例如 IPv4、IPv6、UNIX 套接字等）。

因为在Unix早期版本，C没有`void *`的指针，为了支持更多的协议，便设计出了`struct sockaddr`
各种协议可以定义自己的地址结构，只要前两个字段（如 `sin_family`）一致即可。
- 在调用时，程序员必须将协议相关的结构指针**强制转换**为 `struct sockaddr *`，并传入函数。
例如：
```c
struct sockaddr_in addr;
// 填充 addr...

bind(sockfd, (struct sockaddr *)&addr, sizeof(addr));
```

#### socket函数

客户端和服务器使用socket函数来创建一个套接字描述符：
```c
#include <sys/types.h>
#include <sys/socket.h>

int socket(int domain, int type, int protocol);

// 返回：若成功则为非负描述符，若出错则为 -1。
```

把参数写死，让套接字成为连接的一个端点。
```
clientfd=Socket(AF_INET,SOCK_STREAM,0);
```
但这种硬编码缺乏灵活性
**更好的方式：使用 `getaddrinfo()` 动态生成参数**

AF_INET 表示IPv4，SOCK_STREAM表示面向连接的流式套接字。
socket返回的clientfd描述符只是部分打开，不能用于读写。

#### connect函数

客户端通过调用connect函数建立和服务器连接。
```c
#include <sys/socket.h>

int connect(int clientfd, const struct sockaddr *addr,
            socklen_t addrlen);

// 返回：若成功则为 0，若出错则为 -1。
```

- `clientfd`：客户端套接字文件描述符，通常由 `socket()` 创建。
- `addr`：目标服务器的地址（通常是一个 `sockaddr_in` 或 `sockaddr_in6` 的地址）。
- `addrlen`：地址结构的大小，如 `sizeof(struct sockaddr_in)`。

`connect()` 尝试建立客户端与服务器之间的 TCP 连接。
如果成功连接，它返回 `0`，失败则返回 `-1` 并设置 `errno`。
**默认情况下是阻塞的** —— 程序会卡住，直到： 
连接建立完成，或 发生错误（如连接超时、服务器拒绝等）。
连接成功后，就可以进行读写了。

#### bind、listen、accept函数

剩下的套接字函数——`bind  listen  accept`，服务器用它们来和客户端建立连接。

```c
#include <sys/socket.h>

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

int listen(int sockfd, int backlog);
// 返回：若成功则为 0，若出错则为 -1。

int accept(int listenfd, struct sockaddr *addr, int *addrlen);
// 返回：若成功则为非负连接描述符，若出错则为 -1。
```
bind把addr的服务器套接字地址和描述符sockfd联系起来。
listen把sockfd变成一个监听套接字，可以接受来自客户端的连接请求。
服务器调用accept来等待来自客户端的请求。
accept函数等待客户端连接请求到达listenfd，把客户端套接字地址写入addr，返回一个已连接描述符。

监听描述符作为客户端连接请求的一个端点，创建一次，存在于服务器整个生命周期。
已连接描述符是客户端和服务器之间已经建立的连接的端点，服务器每次接受连接请求都会创建一次，存在于服务器为一个客户端服务的过程中。

简单地说，就是服务器利用listen监听有无客户端请求，每收到一次请求就调用accept来创建一个连接描述符。

- 首先，服务器调用accept，阻塞，等待连接请求到达listenfd。
- 客户端调用connect函数，发送连接请求到达listenfd。
- accept函数打开一个新的已连接描述符connfd，在clientfd和connfd之间建立连接，返回connfd给应用程序。客户端也从connect返回。
- 之后，客户端和服务器就可以分别通过读和写clientfd和connfd来回传送数据。

TCP三次握手在connect和accept之间。
**客户端调用 `connect()` 发起连接 → 内核执行三次握手 → 服务器 `accept()` 返回 `connfd` → 读写数据在 `clientfd` & `connfd` 上进行**


#### 主机和服务的转换

Linux提供了一些函数来实现二进制套接字地址结构和主机名、主机地址、服务器和端口号的字符串表示之间的相互转化。
这些函数和套接字接口一块用可以编写独立于任何特定版本协议的网络程序。

### getaddrinfo函数

getaddrinfo函数把主机名、主机地址、服务名和端口号的字符串转化成套接字地址结构。
（如 `"www.example.com"` 和 `"http"` 或 `"8080"`）转换成 **套接字地址结构**（如 `sockaddr_in` 或 `sockaddr_in6`），供后续的 `connect()` 或 `bind()` 使用。
它是可重入的，适用于任何协议。
```c
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

int getaddrinfo(const char *host, const char *service,
                const struct addrinfo *hints,
                struct addrinfo **result);
// 返回：如果成功则为 0，如果错误则为非零的错误代码。

void freeaddrinfo(struct addrinfo *result);
// 返回：无。

const char *gai_strerror(int errcode);
// 返回：错误消息。
```
给定 host 和 service（套接字地址的两个组成部分），`getaddrinfo`返回 `result`，`result` 一个指向 `addrinfo` 结构的链表，其中每个结构指向一个对应于 host 和 service 的套接字地址结构.

在客户端调用了 `getaddrinfo` 之后，会遍历这个`addinfo`结构的列表，依次尝试每个套接字地址，直到调用 socket 和 connect 成功，建立起连接。类似地，服务器会尝试遍历列表中的每个套接字地址，直到调用 socket 和 bind 成功，描述符会被绑定到一个合法的套接字地址。

为什么要依次尝试每个套接字地址？
**因为无法预知哪一个地址是有效且可用的。**
例如：
- 当前互联网上有的主机只有 IPv4，有的支持 IPv6，有的两个都支持。
- 客户端不知道服务器到底在哪种协议族下可用，所以必须尝试两者。
```c
for (p = res; p != NULL; p = p->ai_next) {
    sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
    if (sockfd == -1) continue;   // 创建失败（比如不支持 IPv6）

    if (connect(sockfd, p->ai_addr, p->ai_addrlen) == 0) {
        break; // 成功
    }
    close(sockfd); // 连接失败，尝试下一个
}
```
为了避免内存泄漏，应用程序必须在最后调用 freeaddrinfo，释放该链表。如果 `getaddrinfo` 返回非零的错误代码，应用程序可以调用 gai_streeror，将该代码转换成消息字符串。

为什么？
### `getaddrinfo` 执行了很多复杂操作：

- DNS解析（把域名转成 IP 地址）
- 协议和服务查询（例如 “http” → TCP/80）
- 填充地址结构（根据 IPv4/IPv6 等）

很多因素都可能导致它失败，不可能简单用-1表达所有情况，所以它使用 **非零错误码** 表示不同的错误类型，用 `gai_strerror` 转换后可以得到人能看懂的错误信息。

**必须指定 host 或 service 中的至少一个**，否则 `getaddrinfo` 无法生成任何有效的地址结果。

`hints` 是一个 `struct addrinfo` 类型的结构体，专门用来指定你对查询结果的“要求”或“过滤条件”。**它是可选的**（为 NULL 时表示不设置任何过滤条件），但在实际编程中，很常用来：

- 限制返回的地址类型（IPv4/IPv6）
- 指定使用的 socket 类型（TCP/UDP）
- 告诉系统我们要用于客户端还是服务器（通过 flags）

```c
struct addrinfo {
    int              ai_flags;     // 通过标志位改变行为（如 AI_PASSIVE）
    int              ai_family;    // IPv4(AF_INET), IPv6(AF_INET6), AF_UNSPEC
    int              ai_socktype;  // SOCK_STREAM (TCP), SOCK_DGRAM (UDP)
    int              ai_protocol;  // 通常为 0，表示系统自动选择
    // ...
};
```
用来过滤result返回的链表的套接字地址。

**使用 `getaddrinfo` 返回的 `addrinfo` 结构体，可以让程序在不考虑底层网络协议细节（如 IPv4 或 IPv6）的情况下进行网络编程**，从而做到更具移植性和通用性。

### getnameinfo函数

`getnameinfo`函数和 `getaddrinfo` 是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串，它是可重入和与协议无关的。
```c
#include <sys/socket.h>
#include <netdb.h>

int getnameinfo(const struct sockaddr *sa, socklen_t salen,
                char *host, size_t hostlen,
                char *service, size_t servlen, int flags);

// 返回：如果成功则为 0，如果错误则为非零的错误代码。 
```
getnameinfo函数将套接字地址结构sa转换成对应的主机和服务名字符串，并将它们复制到host和service缓冲区。

#### 套接字接口的辅助函数

###### open_clientfd函数
客户端调用open_clientfd函数建立与服务器的连接。

```c
#include "csapp.h"

int open_clientfd(char *hostname, char *port);

// 返回：若成功则为描述符，若出错则为 -1。
```
服务器运行在主机hostname上，在port端口监听连接请求。

首先，调用getaddrinfo函数，返回addrinfo结构的链表，每个结构指向一个套接字地址结构，可用于与服务器建立连接。遍历链表，直到调用socket和connect成功。如果connect失败，在尝试下一个条目时需关闭套接字描述符，如果connect成功，会释放列表内存，把套接字描述符返回给客户端，客户端可使用UnixI/O与服务器通信。

###### open_listenfd函数
```c
#include "csapp.h"

int open_listenfd(char *port);

// 返回：若成功则为描述符，若出错则为 -1。
```
`open_listenfd`函数打开和返回一个监听描述符，这个描述符准备好在端口 port上接收连接请求。

open_listenfd也会调用getaddrinfo，直到调用socket和bind成功。

大致模板：
```c
struct addrinfo hints, *listp, *p;
int rc, clientfd;

memset(&hints, 0, sizeof(struct addrinfo));
hints.ai_family = AF_UNSPEC;     // IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM; // TCP

if ((rc = getaddrinfo(host, port, &hints, &listp)) != 0) {
    fprintf(stderr, "getaddrinfo error: %s\n", gai_strerror(rc));
    exit(1);
}

/* 遍历地址列表，直到 connect 成功 */
for (p = listp; p; p = p->ai_next) {
    if ((clientfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0)
        continue;
    if (connect(clientfd, p->ai_addr, p->ai_addrlen) != -1)
        break; // success
    close(clientfd);
}
freeaddrinfo(listp);
```
由此模板产生的open_clientfd函数和openlistenfd函数：

```c
int open_clientfd(char *hostname, char *port) {
    int clientfd;
    struct addrinfo hints, *listp, *p;

    /* Get a list of potential server addresses */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_socktype = SOCK_STREAM;  /* Open a connection */
    hints.ai_flags = AI_NUMERICSERV;  /* ... using a numeric port arg. */
    hints.ai_flags |= AI_ADDRCONFIG;  /* Recommended for connections */
    Getaddrinfo(hostname, port, &hints, &listp);

    /* Walk the list for one that we can successfully connect to */
    for (p = listp; p; p = p->ai_next) {
        /* Create a socket descriptor */
        if ((clientfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0)
            continue; /* Socket failed, try the next */

        /* Connect to the server */
        if (connect(clientfd, p->ai_addr, p->ai_addrlen) != -1)
            break; /* Success */
        Close(clientfd); /* Connect failed, try another */
    }

    /* Clean up */
    Freeaddrinfo(listp);
    if (!p) /* All connects failed */
        return -1;
    else    /* The last connect succeeded */
        return clientfd;
}
```

```c
int open_listenfd(char *port)
{
    struct addrinfo hints, *listp, *p;
    int listenfd, optval = 1;

    /* Get a list of potential server addresses */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_socktype = SOCK_STREAM;             /* Accept connections */
    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; /* ... on any IP address */
    hints.ai_flags |= AI_NUMERICSERV;            /* ... using port number */
    Getaddrinfo(NULL, port, &hints, &listp);

    /* Walk the list for one that we can bind to */
    for (p = listp; p; p = p->ai_next) {
        /* Create a socket descriptor */
        if ((listenfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0)
            continue; /* Socket failed, try the next */

        /* Eliminates "Address already in use" error from bind */
        Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,
                   (const void *)&optval , sizeof(int));

        /* Bind the descriptor to the address */
        if (bind(listenfd, p->ai_addr, p->ai_addrlen) == 0)
            break; /* Success */
        Close(listenfd); /* Bind failed, try the next */
    }
    /* Clean up */
    Freeaddrinfo(listp);
    if (!p) /* No address worked */
        return -1;

    /* Make it a listening socket ready to accept connection requests */
    if (listen(listenfd, LISTENQ) < 0) {
        Close(listenfd);
        return -1;
    }
    return listenfd;
}
```
#### echo客户端和服务器的示例：

```c
#include "csapp.h"
//客户端主程序
int main(int argc, char **argv)
{
    int clientfd;
    char *host, *port, buf[MAXLINE];
    rio_t rio;

    if (argc != 3) {
        fprintf(stderr, "usage: %s <host> <port>\n", argv[0]);
        exit(0);
    }
    host = argv[1];
    port = argv[2];

    clientfd = Open_clientfd(host, port);
    Rio_readinitb(&rio, clientfd);
    //指定rio内部缓冲区从clientfd处获取内容

    while (Fgets(buf, MAXLINE, stdin) != NULL) {//把用户输入读入buf
        Rio_writen(clientfd, buf, strlen(buf));
        //对 `clientfd` 写入 `buf` 的内容，长度为 `strlen(buf)`，rio保证全部写入。
        Rio_readlineb(&rio, buf, MAXLINE);
        //从服务器读取响应。
        Fputs(buf, stdout);
    }
    Close(clientfd);
    exit(0);
}
```

## `argv`（argument vector）

- 类型：`char **argv` 或 `char *argv[]`
- 含义：字符串数组，每个元素是一个命令行参数

- `if (argc != 3)`  
    检查用户是否正确输入了两个参数（host 和 port）。如果没输入，就打印使用方法并退出。
- `fprintf(stderr, "usage: %s <host> <port>\n", argv[0]);`  
    打印提示信息，`argv[0]` 是程序名，比如 `./client`。
- `host = argv[1];`  
    第一个用户输入的参数是服务器主机名或 IP，比如 `"www.example.com"`。
- `port = argv[2];`  
    第二个参数是端口号，例如 `"80"` 或 `"8080"`。

`rio_readlineb`有阻塞特性，保证了客户端会读取服务器的响应。
`rio_readinit`表示以后所有从 `rio` 读取数据的操作，都从这个套接字clientfd读
`rio_readlineb`表示从rio的缓冲区中读数据到buf

```c
//服务器主程序
#include "csapp.h"

void echo(int connfd);

int main(int argc, char **argv)
{
    int listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr; /* Enough space for any address */
    char client_hostname[MAXLINE], client_port[MAXLINE];

    if (argc != 2) {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(0);
    }
    //指定输入的是服务器要监听的端口号
    listenfd = Open_listenfd(argv[1]); //创建套接字，bind端口号，开始监听
    while (1) {
        clientlen = sizeof(struct sockaddr_storage);
        connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen);
        Getnameinfo((SA *) &clientaddr, clientlen, client_hostname, MAXLINE,
                    client_port, MAXLINE, 0);
        printf("Connected to (%s, %s)\n", client_hostname, client_port);
        echo(connfd);
        Close(connfd);
    }
    exit(0);
}
```
```c
#include "csapp.h"
void echo(int connfd)
{
    size_t n;
    char buf[MAXLINE];
    rio_t rio;

    Rio_readinitb(&rio, connfd);
    while ((n = Rio_readlineb(&rio, buf, MAXLINE)) != 0) {
        printf("server received %d bytes\n", (int)n);
        Rio_writen(connfd, buf, n);
    }
}
```

服务器会从网络上接收到客户端的信息，把它放到内核缓冲区，然后connfd可以从内核缓冲区中读到这段信息。

EOF是内核检测到的一种条件。
应用程序在它接收到由read函数返回的0时，就会发生EOF。
对于磁盘文件，当前文件位置超出文件长度时，会发生EOF。
对于因特网，当一个进程关闭连接它的那一端时，会发生EOF。
连接另一端进程试图读流的最后字节之后的字节时，会检测到EOF。


**程序执行时，遇到描述符和套接字会通过当前进程的“文件描述符表”查找对应的对象**。


