
并发(concurrent)不仅仅是内核让多个应用程序“同时”运行的能力，在应用层面上也有并发的实现。

也许程序运行时只有一个进程，但进程内部可能有：

- 多个线程
- 信号处理程序
- 事件循环（如 Node.js）
- 异步 I/O
- 协程
- 回调函数
这些都属于应用级并发。

现代操作系统提供了三种基本的构造并发程序的方法:
- 进程。各个进程之间独立，通过进程间通信交换信息。由内核调度。
- I/O多路复用。应用程序在一个进程中调用逻辑流。每个逻辑流是一个状态机。当数据到达某个文件描述符，fd可读/可写时，会从一个状态切换到另一个状态。由应用程序调度。
- 线程。一个进程中的多个逻辑流。由内核调度，共享这个进程的虚拟地址空间。

## 12.1基于进程的并发编程

构造并发程序最简单的就是用进程。一个构造并发服务器的方法是：在父进程中接受客户端的连接请求，创造一个新的子进程来为每个新客户端服务。

父进程用监听描述符来接受客户端请求，在接受连接请求后，父进程创建已连接描述符，并fork子进程。父进程关闭自己的已连接描述符，继续监听，子进程关闭监听描述符，用已连接描述符来通信。
##### 为什么要关闭已连接描述符？
因为父进程和子进程的已连接描述符指向同一个文件表表项，不关闭会导致文件表条目无法释放，会造成内存泄漏。

### 12.1.1基于进程的并发服务器
服务器通常需要运行很长时间，这表示需要用一个处理程序来回收僵尸子进程的资源。

- 子进程执行完毕会退出，进入 **僵尸状态（Z state）**
- 父进程必须调用 `wait()` 或 `waitpid()` 来回收它
- 否则系统中的僵尸进程会越来越多，占用 PID 和内核资源
父进程一般在处理主循环（如 accept），不方便立即 wait。  

于是我们让内核在子进程退出时发送一个 **SIGCHLD** 到父进程。

```c
void sigchld_handler(int sig)
{
    while (waitpid(-1, 0, WNOHANG) > 0)
        ;
    return;
}

```
使用while来一次性回收多个子进程。

并发服务器代码：
```c
#include "csapp.h"
void echo(int connfd);

void sigchld_handler(int sig)
{
    while (waitpid(-1, 0, WNOHANG) > 0)
        ;
    return;
}

int main(int argc, char **argv)
{
    int listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;

    if (argc != 2) {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(0);
    }

    Signal(SIGCHLD, sigchld_handler);
    listenfd = Open_listenfd(argv[1]);
    while (1) {
        clientlen = sizeof(struct sockaddr_storage);
        connfd = Accept(listenfd, (SA *) &clientaddr, &clientlen);
        if (Fork() == 0) {
            Close(listenfd); /* Child closes its listening socket */
            echo(connfd);    /* Child services client */
            Close(connfd);   /* Child closes connection with client */
            exit(0);         /* Child exits */
        }
        Close(connfd); /* Parent closes connected socket (important!) */
    }
}
```
`Signal(SIGCHLD, sigchld_handler);`表示，子进程结束时，内核向父进程发送SIGCHLD信号，在收到SIGCHLD信号时，程序应该执行sigchld_handler函数。

父子进程拥有各自独立的虚拟地址空间，这样，两个进程不会覆盖各自的虚拟内存。
但是，独立的虚拟地址空间也使得两个进程的通信变得困难，需要使用`IPC(interprocess communication,进程间通信)`。而这开销较高。

## 基于I/O多路复用的并发编程

```c
select(fd1, fd2, fd3...)
```
本意是通过select来监视各描述符，当这些描述符有一个准备好，即可把控制返还给应用程序。

#### select函数
```c
#include <sys/select.h>

int select(int n, fd_set *fdset, NULL, NULL, NULL);
// 返回已准备好的描述符的非零的个数，若出错则为 -1。

FD_ZERO(fd_set *fdset);           /* Clear all bits in fdset */
FD_CLR(int fd, fd_set *fdset);    /* Clear bit fd in fdset */
FD_SET(int fd, fd_set *fdset);    /* Turn on bit fd in fdset */
FD_ISSET(int fd, fd_set *fdset);  /* Is bit fd in fdset on? */
// 处理描述符集合的宏。
```
fd_set为描述符集合，用位向量来表示描述符是否存在于fd_set。
如果fd_set中无描述符可读，就挂起进程。
此外，select会修改传入的fd_set，删去所有不可读的fd。
所以需要在每次调用select时更新读的集合。
select的作用：**让程序在某个事件发生前一直阻塞，避免不断轮询**。

利用select来实现迭代echo服务器：
```c
#include "csapp.h"
void echo(int connfd);
void command(void);

int main(int argc, char **argv)
{
    int listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    fd_set read_set, ready_set;
    
    if (argc != 2) {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(0);
    }
    listenfd = Open_listenfd(argv[1]);
    
    FD_ZERO(&read_set);              /* Clear read set */
    FD_SET(STDIN_FILENO, &read_set); /* Add stdin to read set */command输入
    FD_SET(listenfd, &read_set);     /* Add listenfd to read set */监听

    while (1) {
        ready_set = read_set;//保存原始的集合
        Select(listenfd + 1, &ready_set, NULL, NULL, NULL);
        if (FD_ISSET(STDIN_FILENO, &ready_set))
            command(); /* Read command line from stdin */
        if (FD_ISSET(listenfd, &ready_set)) {
            clientlen = sizeof(struct sockaddr_storage);
            connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen);
            echo(connfd); /* Echo client input until EOF */
            Close(connfd);
        }
    }
}

void command(void) {
    char buf[MAXLINE];
    if (!Fgets(buf, MAXLINE, stdin))
        exit(0); /* EOF */
    printf("%s", buf); /* Process the input command */
}
```

#### 并发事件驱动服务器

结构体pool：
```c
typedef struct {
    int maxfd;        
    fd_set read_set;  
    fd_set ready_set; 
    int nready; //已就绪的描述符的数量      
    int maxi;  //客户端描述符数组的最大有效索引       
    int clientfd[FD_SETSIZE];    //客户端的描述符集合
    rio_t clientrio[FD_SETSIZE];//
} pool;
```
pool结构里维护活动客户端的集合，管理所有的客户端 + 监听描述符。

并发echo服务器：
```c
#include "csapp.h"

int byte_cnt = 0; /* Counts total bytes received by server */

int main(int argc, char **argv)
{
    int listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    static pool pool;

    if (argc != 2) {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(0);
    }
    listenfd = Open_listenfd(argv[1]);
    init_pool(listenfd, &pool);

    while (1) {
        /* Wait for listening/connected descriptor(s) to become ready */
        pool.ready_set = pool.read_set;
        pool.nready = Select(pool.maxfd + 1, &pool.ready_set, NULL, NULL, NULL);
        //客户端准备好数据
        /* If listening descriptor ready, add new client to pool */
        if (FD_ISSET(listenfd, &pool.ready_set)) {//有新连接到达
            clientlen = sizeof(struct sockaddr_storage);
            connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen);
            add_client(connfd, &pool);//添加新客户端到pool池中
        }
        
        /* Echo a text line from each ready connected descriptor */
        check_clients(&pool);
    }
}
```

#### add_client函数
```c
void add_client(int connfd, pool *p)
{
    int i;
    p->nready--;
    for (i = 0; i < FD_SETSIZE; i++) /* Find an available slot */
        if (p->clientfd[i] < 0) {
            /* Add connected descriptor to the pool */
            p->clientfd[i] = connfd;
            Rio_readinitb(&p->clientrio[i], connfd);

            /* Add the descriptor to descriptor set */
            FD_SET(connfd, &p->read_set);

            /* Update max descriptor and pool high water mark */
            if (connfd > p->maxfd)
                p->maxfd = connfd;
            if (i > p->maxi)
                p->maxi = i;
            break;
        }
    if (i == FD_SETSIZE) /* Couldn’t find an empty slot */
        app_error("add_client error: Too many clients");
}
```
先在clientfd里面为新的已连接描述符找位置，readinitb会指定从connfd里面读取内容，放到相应的rio缓冲区中。之后，FD_SET把connfd添加到池子里，确保能被select到。更新maxfd和maxi，如果找不到位置就报错。

#### check_cilents函数

```c
void check_clients(pool *p)
{
    int i, connfd, n;
    char buf[MAXLINE];
    rio_t rio;

    for (i = 0; (i <= p->maxi) && (p->nready > 0); i++) {
        connfd = p->clientfd[i];
        rio = p->clientrio[i];

        /* If the descriptor is ready, echo a text line from it */
        if ((connfd > 0) && (FD_ISSET(connfd, &p->ready_set))) {
            p->nready--;
            if ((n = Rio_readlineb(&rio, buf, MAXLINE)) != 0) {
                byte_cnt += n;
                printf("Server received %d (%d total) bytes on fd %d\n",
                       n, byte_cnt, connfd);
                Rio_writen(connfd, buf, n);
            }

            /* EOF detected, remove descriptor from pool */
            else {
                Close(connfd);
                FD_CLR(connfd, &p->read_set);
                p->clientfd[i] = -1;
            }
        }
    }
}
```
判断描述符是否在已就绪集合，然后读取rio缓冲区内容。记录总字节和信息，并用rio_writen来回显信息实现echo。如果缓冲区没内容，客户端关闭连接，就关闭connfd，把它从池子里删除，回收在clientfd的位置。

这被称作事件驱动设计，应该是select函数的原因，它可以阻塞等待，每当有描述符就绪就会触发行为。
#### I/O多路复用技术的优劣

**事件驱动设计的一个优点是，它比基于进程的设计给了程序员更多的对程序行为的控制。**
我们可以通过修改rio_writen来实现不同的功能，甚至可以通过判断特殊的描述符来针对不同客户端单独定制行为，程序员可以更精细的控制行为。
基于进程的服务器通过fork很难实现这样的控制。

**另一个优点：I/O 多路复用的事件驱动服务器运行在单一进程上下文中，逻辑流可以直接访问共享数据，方便实现计数、缓存、状态管理等功能。**
单进程也很方便调试。

最后，事件驱动设计常常比基于进程的设计要高效，因为它们不需要进程上下文切换来调度新的流。

**事件驱动设计一个明显的缺点就是编码复杂。**
随着并发粒度的减小，复杂性还会上升,粒度是指每个逻辑流每个时间片执行的指令数量,在示例并发服务器中，并发粒度就是读一个完整的文本行所需要的指令数量。

**基于事件的设计另一个重要的缺点是它们不能充分利用多核处理器。**

此外，单进程对慢/恶意客户端比较脆弱
