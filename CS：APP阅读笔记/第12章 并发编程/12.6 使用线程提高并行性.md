
并发程序在多核处理器上运行的更快，操作系统在多个核上并行地调度这些并发线程。

下面是利用多线程求和 0 + 1 + 2 + ... + (`nelems` − 1)的代码

```c
#include "csapp.h"
#define MAXTHREADS 32

void *sum_mutex(void *vargp); /* Thread routine */

/* Global shared variables */
long gsum = 0;          /* Global sum */
long nelems_per_thread; /* Number of elements to sum */
sem_t mutex;            /* Mutex to protect global sum */

int main(int argc, char **argv)
{
    long i, nelems, log_nelems, nthreads, myid[MAXTHREADS];
    pthread_t tid[MAXTHREADS];

    /* Get input arguments */
    if (argc != 3) {
        printf("Usage: %s <nthreads> <log_nelems>\n", argv[0]);
        exit(0);
    }
    nthreads = atoi(argv[1]);
    log_nelems = atoi(argv[2]);
    nelems = (1L << log_nelems);
    nelems_per_thread = nelems / nthreads;
    sem_init(&mutex, 0, 1);

    /* Create peer threads and wait for them to finish */
    for (i = 0; i < nthreads; i++) {
        myid[i] = i;
        Pthread_create(&tid[i], NULL, sum_mutex, &myid[i]);
    }
    for (i = 0; i < nthreads; i++)
        Pthread_join(tid[i], NULL);

    /* Check final answer */
    if (gsum != (nelems * (nelems - 1)) / 2)
        printf("Error: result=%ld\n", gsum);

    exit(0);
}
```
主线程把求和任务分给子线程，用mutex来确保gsum的更新。

每个线程执行的函数`sum_mutex`如下：
```c
/* Thread routine for psum-mutex.c */
void *sum_mutex(void *vargp)
{
    long myid = *((long *)vargp);          /* Extract the thread ID */
    long start = myid * nelems_per_thread; /* Start element index */
    long end = start + nelems_per_thread;  /* End element index */
    long i;
    
    for (i = start; i < end; i++) {
        P(&mutex);
        gsum += i;
        V(&mutex);
    }
    return NULL;
}
```
很明显可以看出，每个线程在每次加和时都要申请gsum的mutex，这会导致程序很慢。

可以通过把每个线程的部分和存起来，最后再相加。

```c
/* Thread routine for psum-array.c */
void *sum_array(void *vargp)
{
    long myid = *((long *)vargp);          /* Extract the thread ID */
    long start = myid * nelems_per_thread; /* Start element index */
    long end = start + nelems_per_thread;  /* End element index */
    long i;

    for (i = start; i < end; i++) {
        psum[myid] += i;
    }
    return NULL;
}
```
vargp是create时的第四个参数，即每个线程的编号。

**同步开销是十分巨大的，应尽量避免。**

而且，还能够利用局部变量进一步优化：
```c
/* Thread routine for psum-local.c */
void *sum_local(void *vargp)
{
    long myid = *((long *)vargp);          /* Extract the thread ID */
    long start = myid * nelems_per_thread; /* Start element index */
    long end = start + nelems_per_thread;  /* End element index */
    long i, sum = 0;

    for (i = start; i < end; i++) {
        sum += i;
    }
    psum[myid] = sum;
    return NULL;
}
```
这样可以消除对psum的内存引用。

## 12.7 其他并发问题

#### 线程安全

一个函数是**线程安全的**，当且仅当被多个并发线程反复调用时，它会一直产生正确的结果。反之则是**线程不安全**。
大致有四类**线程不安全的函数：**
- **不保护共享变量的函数。**
  这类函数通常可以用信号量来变成安全的。

- **保持跨越多个调用的状态的函数。**
例如：伪随机数生成器。
```c
unsigned next_seed = 1;

/* rand - return pseudorandom integer in the range 0..32767 */
unsigned rand(void)
{
    next_seed = next_seed * 1103515245 + 12543;
    return (unsigned)(next_seed >> 16) % 32768;
}

/* srand - set the initial seed for rand() */
void srand(unsigned new_seed)
{
    next_seed = new_seed;
}
```
rand函数就是线程不安全的，当前调用的结果依赖于前次调用的中间结果。
单线程反复调用rand可以得到可重复的数字序列，但是多线程不行。
**唯一让它安全的方式是重写它。**
- **返回指向静态变量指针的函数。**
这类函数一种方法是重写，一种方法是加锁。
```c
char *ctime_ts(const time_t *timep, char *privatep)
{
    char *sharedp;
    
    P(&mutex);
    sharedp = ctime(timep);
    strcpy(privatep, sharedp); /* Copy string from shared to private */
    V(&mutex);
    return privatep;
}
```

- **调用线程不安全函数的函数。**
严格来说，一个函数调用线程不安全函数，它不一定是线程不安全的。
如果调用的是第二类依赖于跨越多次调用的状态，那么它是不安全的；如果它调用第一类或者第三类，那么可以通过互斥锁来保证安全。

### 可重入性函数

可重入函数（`reentrant function`）：当函数被多个线程调用时，不会引用任何共享数据。

可重入函数是线程安全的函数的真子集。

将第二类不安全函数转化的办法就是重写它，让它变成可重入函数。例如：
```c
/* rand_r - return a pseudorandom integer on 0..32767 */
int rand_r(unsigned int *nextp)
{
    *nextp = *nextp * 1103515245 + 12345;
    return (unsigned int)(*nextp / 65536) % 32768;
}
```
通过传入一个指针取代静态的next变量，让函数可重入。
如果函数参数都是传值传递，没有指针，且没有静态变量和全局变量，那它是显式可重入的。
如果函数参数传递指向非共享变量的指针，那么它是隐式可重入的，就像rand_r。

Linux里面的一些库函数是不可重入的，例如rand、ctime。
但是，Linux也提供了它们的可重入版本，以_r结尾，如：rand_r、ctime_r。

### 竞争

当一个程序的正确性依赖于一个线程在另一个线程的控制流到达y点之前到达它的控制流中的x点，就会产生竞争。
即程序需要依赖特定的线程运行轨迹。而多线程的程序必须对任何可行的轨迹线都正确工作。

例如，在基于I/O多路复用时，我们让connfdp解引用后接收已连接描述符。
如果用connfd来接收的话，那么可能会被下一次accept的返回值覆盖掉。

而解决竞争的方法也正如代码那样，利用动态内存分配，为每个已连接描述符创立独立内存空间。

### 死锁

学过操作系统的很熟悉。
几个进程因互相等待对方释放资源而永远无法进行下去的状态。

死锁避免：

互斥锁加锁顺序规则：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。



