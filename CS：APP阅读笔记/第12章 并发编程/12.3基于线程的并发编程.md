
基于线程的并发编程是基于进程和基于I/O多路复用两个方式的混合。

线程通过内核调度，并且共享虚拟地址空间。
同一进程的所有线程被成为**对等线程**，每个线程都可以杀死，创建，等待其他对等线程。

#### Posix线程

以下是一个Pthreads的程序：
```c
#include "csapp.h"
void *thread(void *vargp);

int main()
{
    pthread_t tid;
    Pthread_create(&tid, NULL, thread, NULL);
    Pthread_join(tid, NULL);
    exit(0);
}

void *thread(void *vargp) /* Thread routine */
{
    printf("Hello, world!\n");
    return NULL;
}
```
程序一运行就进入到主线程，主线程创建对等线程，并且将其线程ID存到tid，让对等线程执行thread函数。 Pthread_join则类似于wait函数，等待对等线程tid执行完。
thread函数就是线程例程，用来封装线程的代码和本地数据，它以一个通用指针作为输入，返回一个通用指针。这些通用指针1可以通过指向一个结构来传入或者返回多个参数。

#### 创建线程
```c
#include <pthread.h>
typedef void *(func)(void *);

int pthread_create(pthread_t *tid, pthread_attr_t *attr,
                   func *f, void *arg);
// 若成功则返回 0，若出错则为非零。
```
该函数创建一个新的线程，带着一个输入变量arg，在新线程上运行`f(arg)`.attr参数可以改变新线程的默认属性，默认为NULL。

#### 终止线程
当线程的f返回时，线程会隐式的终止。
可以通过调用`pthread_exit`函数来显式终止线程。
如果主线程调用`pthread_exit`,则会等待所有对等线程终止，再终止主线程和整个进程。
```c
#include <pthread.h>
void pthread_exit(void *thread_return);
// 从不返回。
```
有的对等线程会调用Linux的exit函数来终止自身所在进程和所有进程内线程。

有的可以用`pthread_cancel`来终止线程。
```c
#include <pthread.h>
int pthread_cancel(pthread_t tid);
// 若成功则返回 0，若出错则为非零。
```
而且，cancel不会立即终止线程，而是请求线程在合适时机(取消点)终止。
常见取消点包括：

- `read`
- `write`
- `select`
- `sleep`
- `pthread_join`
- 以及其它阻塞系统调用

#### 回收终止线程资源
```c
#include <pthread.h>

int pthread_join(pthread_t tid, void **thread_return);

// 若成功则返回 0，若出错则为非零。
```
join只能等待一个指定线程终止，不能和wait一样等待任意进程。

#### 分离线程

线程要么是可结合的(joinable)，要么是分离的(detached)。
线程默认是可结合的，在线程结束后，其资源不会自动释放，需要另一个线程用join来终止它。

当线程通过pthread_detached成为分离的之后，它无法被join，结束后系统会释放资源。

```c
#include <pthread.h>

int pthread_detach(pthread_t tid);

// 若成功则返回 0，若出错则为非零。
```
线程可以通过pthread_self()为参数，来分离自己。

高性能Web服务器常用分离线程。服务器每接一个客户端连接就创建一个线程，如果都需要join来终止的话，为每一个线程都调用join太奢侈了。用detached的话，服务器不需要关系线程何时结束。

#### 初始化线程

```c
#include <pthread.h>

pthread_once_t once_control = PTHREAD_ONCE_INIT;

int pthread_once(pthread_once_t *once_control,
                 void (*init_routine)(void));
// 总是返回 0。
```
pthread_once函数用来确保某个初始化函数在多个线程竞争调用时只会执行一次，并且是线程安全的。

#### 基于线程的并发服务器

```c
#include "csapp.h"

void echo(int connfd);
void *thread(void *vargp);

int main(int argc, char **argv)
{
    int listenfd, *connfdp;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    pthread_t tid;

    if (argc != 2) {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        
        exit(0);
    }
    listenfd = Open_listenfd(argv[1]);
    
    while (1) {
        clientlen = sizeof(struct sockaddr_storage);
        connfdp = Malloc(sizeof(int));
        *connfdp = Accept(listenfd, (SA *) &clientaddr, &clientlen);
        Pthread_create(&tid, NULL, thread, connfdp);
    }
}

/* Thread routine */
void *thread(void *vargp)
{
    int connfd = *((int *)vargp);
    Pthread_detach(pthread_self());
    Free(vargp);
    echo(connfd);
    Close(connfd);
    return NULL;
}
```
`connfdp=Malloc(sizeof(int))`，让accept返回的已连接描述符存向一片独立空间。
监听到新连接后创建新线程。
connfdp传入thread函数作为vargp，解引用后赋值给connfd。
先分离线程，后释放临时内存，再回应客户端，最后关闭描述符，线程结束。

##### 为什么要把accept的返回值赋值给* connfdp，而不是直接赋值给connfd？
因为可能会引起冲突。
主线程可能很快又执行一次 `Accept`，覆盖了前一次的已连接描述符。
分配独立的堆上空间就不会有这样的问题。

