
#### 1.给定一个包含n个成员的社交网络和一个包含m对成员建立友谊的时间戳的日志文件，设计一种算法来确定所有成员最早建立联系的时间。假设日志文件是按时间戳排序的，并且友谊是等价关系。

利用并查集检查连通分量，当连通分量为1的时候，就是所有成员最早建立联系的时候。

```python
count = n *初始化连通分量
for (t, p, q) in log:
    if not connected(p, q):
        union(p, q)
        count -= 1
        if count == 1:
            return t

return "never fully connected"
```

#### 2.为 union-find 数据类型添加一个方法find(),find(i)返回包含i的连通组件中最大的元素。

这样的话需要维护一个max数组，记录每个连通分量的最大值。

```c
int maxvalue[N]={0};

int max(int a, int b) {
    return a > b ? a : b;
}

void union_max(int x,int y)
{
    int px=find(x);
    int py=find(y);
    if(size[px]<size[py])//y的大
    {
        a[px]=py;
        size[py]=size[px]+size[py];
        maxvalue[py]=max(maxvalue[px],maxvalue[py]);
    }
    else
    {
        a[py]=px;
        size[px]=size[px]+size[py];
        maxvalue[px]=max(maxvalue[px],maxvalue[py]);
    }
}
int find_max(int x)
{
int px=find(x);
return maxvalue[px];
}
```
初始化时，需要让每个节点的max值＝它本身。

#### 3.给定一组nnn 整数S={0,1,...,n−1}和如下形式的请求序列：
- 将x从S中删除。
- 找出x的继承者：S中最小的y使得y≥x。

思路：
每次删除x时，将x和x+1合并在一起。
这样的话，每次查找x的继承者时，直接find到x+1。

但是这样的话，合并时无法根据权重来合并树。防止大数的根节点变成小数。