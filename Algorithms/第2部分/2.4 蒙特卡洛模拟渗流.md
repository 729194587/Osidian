
**蒙特卡洛模拟(Monte Carlo Simulation)** 是一种利用随机性来解决数学或物理问题的计算方法。在渗流（Percolation）问题中，我们使用蒙特卡洛方法来估计渗流阈值（Percolation Threshold）——即系统首次渗流时所需开放的站点占总站点的比例。

#### 1. 渗流模型（Percolation Model）

我们通常考虑一个 **n × n 的方格晶格**。  
每个格子（site）可能是：
- **开放（open）**：流体可以通过
- **封闭（blocked）**：不允许流体通过
渗流的定义：当系统中存在一条路径，可以从**顶部一行**连续通过开放站点，一直连通到**底部一行**，就称系统发生渗流。
#### 2. 为什么要用蒙特卡洛模拟？

对于随机打开站点的过程，渗流发生在大约某个固定比例附近（例如方格渗流大约约为 0.59）。  
但这个阈值没有简单的公式可以直接计算，因此我们用大量实验来估计。

蒙特卡洛模拟就是：  **重复随机模拟很多次，然后通过统计结果得到估计值。**
每次实验大致如下：

1. **初始化**
    - 创建一个 `n×n` 的格子
    - 所有站点先保持封闭状态
2. **随机开放站点**
    - 从所有封闭站点中随机选择一个
    - 将其打开
    - 记录目前开放站点的数量
3. **检测是否渗流**
    - 如果系统已经从顶部连通到底部，则实验结束
4. **计算本次实验的渗流阈值**
    p=打开的站点数/n\*n
这个 p 就是本次实验得到的估计值。

###  `void PercolationStats(int n, int trials)`

该函数用于进行trials模拟，并记录下来每次实验的渗流阈值。
先前已经实现了和渗流有关的各种函数，现在只需要实现随机开放站点，判断渗流即可。
但是一个问题来了：**如何随机开放站点？**

如果每次用rand函数模N\*N，判断是否开放的话，那么到后面随机开放站点会越来越难，这样的话，函数时间复杂度会很高。
解决办法：**先建一个所有格子编号的数组，随机打乱**

#### Fisher–Yates 洗牌算法

目标：  给定一个数组 `site[]`，它里面存着所有格子的编号，例如 0,1,2,…,N-1。我们希望将这个数组**完全随机打乱**（每一种排列出现的概率都相等）。
核心思想：
> **从后往前遍历，每次把当前位置的元素与前面任意一个随机位置的元素交换。**

```c
            int total = N * N;
            int *site = malloc(total * sizeof(int));

            for (int i = 0; i < total; i++)
                site[i] = i;

            for (int i = total - 1; i > 0; i--) {//洗牌
                int r = rand() % (i + 1);//随机选一个位置
                int tmp = site[i];//把第i个位置元素换过去。
                site[i] = site[r];
                site[r] = tmp;
            }
```

我最终实现的函数如下：
```c
     for(int i=0;i<trials;i++)
     {
            srand(time(NULL));
            Percolation(n);//初始化网格和并查集
            int count=0;
                        int total = N * N;
            int *site = malloc(total * sizeof(int));

            for (int i = 0; i < total; i++)
                site[i] = i;

            for (int i = total - 1; i > 0; i--) {//洗牌
                int r = rand() % (i + 1);//随机选一个位置
                int tmp = site[i];//把第i个位置元素换过去。
                site[i] = site[r];
                site[r] = tmp;
            }

            while(!percolates())
            {
            int row=count/N;
            int col=count%N;
            Open(row,col);
            count++;
            }
            result[i]=((double)count)/N*N;
     }
```
但是我很快发现了一个问题。(事实上我写的函数有很多问题)
percolationstats的动态内存需要释放。
但是后面的求阈值均值、置信区间等函数需要用到这个result。
这样在哪释放内存呢？又怎么能让后面的函数访问到这个result数组？

chatGPT告诉我，我应该实现一个结构体来进行整个实验。
课程用的是Java语言，能自动回收new的内存，但是C不行。

```c
    typedef struct {
    int n;          // 网格大小 n×n
    int trials;     // 实验次数
    double* results; // 保存每次实验得到的渗流阈值
} PercolationS;
```

下面是我优化后的PercolationStats函数：
```c
 bool PercolationStats(int n, int trials,PercolationS* ps)
    {
        if(trials<=0)
        {
            return false;
        }
        ps->results=(double *)malloc(trials*sizeof(double));
        if (!ps->results)
            return false;

        ps->n=n;
        ps->trials=trials;
     for(int i=0;i<trials;i++)
     {
            Percolation(n);//初始化网格和并查集
            int count=0;
            int total = N * N;
            int *site = (int*)malloc(total * sizeof(int));
            if(!site) 
                return false;

            for (int j = 0; j < total; j++)
                site[j] = j;

            for (int k = total - 1; k > 0; k--) {//洗牌
                int r = rand() % (k + 1);//随机选一个位置
                int tmp = site[k];//把第i个位置元素换过去。
                site[k] = site[r];
                site[r] = tmp;
            }

            while(!percolates())
            {
            int pos=site[count];
            int row=pos/N;
            int col=pos%N;
            Open(row,col);
            count++;
            }
            ps->results[i]=((double)count)/(N*N);
            free(site);
            free(a);
            free(size);
            free(open);
     }
     return true;
    }

```
- 新增加了对malloc函数动态分配是否成功的判断。
- 新增加了结构体变量PercolationS并对相关代码进行修改。
- 新增加了用于循环的变量j、k，防止i混乱。
- 新增加了Percolations.h文件，用于声明函数。
- 新增加了对试验次数的判断，试验次数必须为正。
- 修复了计算result值时运算符号的优先级问题。
- 修复了使用count直接计算row和col导致洗牌未生效的问题。

这样，我的最终代码如下：
```c
#include"Percolation.c"
#include <time.h>
#include"Percolation.h"
    // 在 n×n 网格上进行独立试验
    typedef struct {
    int n;          // 网格大小 n×n
    int trials;     // 实验次数
    double* results; // 保存每次实验得到的渗流阈值
} PercolationS;

   bool PercolationStats(int n, int trials,PercolationS* ps)
    {
        if(trials<=0)
        {
            return false;
        }
        ps->results=(double *)malloc(trials*sizeof(double));
        if (!ps->results)
            return false;

        ps->n=n;
        ps->trials=trials;
     for(int i=0;i<trials;i++)
     {
            Percolation(n);//初始化网格和并查集
            int count=0;
            int total = N * N;
            int *site = (int*)malloc(total * sizeof(int));
            if(!site) 
                return false;

            for (int j = 0; j < total; j++)
                site[j] = j;

            for (int k = total - 1; k > 0; k--) {//洗牌
                int r = rand() % (k + 1);//随机选一个位置
                int tmp = site[k];//把第i个位置元素换过去。
                site[k] = site[r];
                site[r] = tmp;
            }

            while(!percolates())
            {
            int pos=site[count];
            int row=pos/N;
            int col=pos%N;
            Open(row,col);
            count++;
            }
            ps->results[i]=((double)count)/(N*N);
            free(site);
            free(a);
            free(size);
            free(open);
     }
     return true;
    }

    //释放results的内存
    void PercolationS_destroy(PercolationS* ps)
    {
    if(ps->results) free(ps->results);
    }

    // 渗流阈值的样本均值
    double mean(PercolationS* ps)
    {
    double aver=0;
    int trials=ps->trials;
    for(int i=0;i<trials;i++)
    {
        aver+=ps->results[i];
    }
    return aver/trials;
    }
    
int main()
{
    srand(time(NULL));
    PercolationS ps;
    PercolationStats(10,10,&ps);
    double ave=mean(&ps);
    printf("%f",ave);
    PercolationS_destroy(&ps);
    return 0;
}
```
其中，Percolation.h文件用于函数声明
```c
//用于防止头文件被重复包含
#ifndef PERCOLATION_H //如果宏未定义
#define PERCOLATION_H//则定义它，声明函数

#include <stdbool.h>

bool Percolation(int n);
void Open(int row, int col);
bool percolates();

#endif//已定义，直接结束。
```

##### 运行结果

- 10\*10的网格，实验10次，得到的平均阈值为0.562000
- 10\*10的网格，实验20次，得到的平均阈值为0.576500
- 20\*20的网格，实验20次，得到的平均阈值为0.586750
- 20\*20的网格，实验100次，得到的平均阈值为0.594050

理论极限阈值大约为 0.592746。

#### 3.渗流的数理统计

接下来，我们计算渗流模型阈值的标准差、置信区间。

```c
 //渗流阈值的样本标准偏差
    double stddev(PercolationS* ps)
    {
      double ave=mean(ps);
      int trials=ps->trials;
      double sum=0;
      for(int i=0;i<trials;i++)
      {
        double dis=ps->results[i]-ave;
        sum+=dis*dis;
      }
      return sqrt(sum/(trials-1));
    }
```

```c
    // 95% 置信区间的下限
     double confidenceLo(double mean,double stddev,int trials)
    {
     return mean - 1.96 * stddev / sqrt(trials);
    }

    // 95% 置信区间的上限
     double confidenceHi(double mean,double stddev,int trials)
    {
     return mean + 1.96 * stddev / sqrt(trials);
    }
```

运行结果：

![[蒙特卡洛模拟渗流运行结果.png]]

#### 4.总结
利用并查集实现了渗流模型，并利用蒙特卡洛模拟来进行独立实验，统计渗流阈值渗流阈值的均值、标准差、置信区间。
C语言的动态内存分配很麻烦。
Fisher-Yates 洗牌生成随机顺序，而不是用随机数对N\*N取模，那样的话后面的效率会很低。
实验结果显示渗流阈值大约在 0.59 左右，符合理论预期。

