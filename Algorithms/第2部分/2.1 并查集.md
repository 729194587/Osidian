
## Quick Find

使用一个数组来支持并查集的快速查找。

两个对象 P 和 Q **当且仅当** 它们在数组中的值相同时，才认为它们是连通的。
查找操作只需检查数组中的值是否相等，即可得知两个是否连通。

合并操作：
把数组中 **与其中一个对象的 ID 相同的所有元素** 改成另一个对象的 ID。
这在对象数量很大时效率不高。

```c
#include<stdio.h>

# define N 10

int a[N]={0};
int connected(int x,int y )
{
    return a[x]==a[y];
}
void union_UF(int x,int y)
{
    int xid=a[x];
    int yid=a[y];
    for(int i=0;i<N;i++)
    {
        if(a[i]==xid)
        a[i]=yid;
    }
    return;
};

int main()
{
//初始化
for(int i=0;i<N;i++)
    a[i]=i;
    return 0;
}
```
死去的记忆苏醒了：
并查集用树来实现，每个节点存它的根节点祖先。
这样合并时只需要把小树的祖先节点的祖先改为大树的祖先节点即可。
查找的时候，看祖先节点是否一样。

## Quick Union

```c
int connected(int x,int y)
{
    while(x!=a[x])
    x=a[x];
    while(y!=a[y])
    y=a[y];
    return (x==y);
}

void union_UF(int x,int y)
{

    while(x!=a[x])
    x=a[x];
    while(y!=a[y])
    y=a[y];
    
     a[x]=y;//合并根节点。
    return;
}
```
这样就实现了quick union。
但是，每次查找根节点的时候都要从当前节点往上一步一步找，效率较慢。
可以通过**路径压缩来提高效率。**

```c
int find(int x)
{
    int tmp=a[x];
    if(x!=tmp)
    a[x]=find(tmp);
    return a[x];
}
int connected_p(int x,int y)
{
    int px=find(x);
    int py=find(y);
    return px==py;
}

void union_p(int x,int y)
{
int px=find(x);
int py=find(y);
a[px]=py;
return;
}
```
利用find函数，把当前节点直接指向根节点。

此外，还可以通过把小树合并到大树下来避免树过高，通常使用一个**权值来记录树的数量。**

```c
//带权值的
int size[N]={0};
void union_pw1(int x,int y)
{
    int px=find(x);
    int py=find(y);
    if(size[px]<size[py])//y的大
        a[px]=py;
    else
        a[py]=px;
    int new_size=size[px]+size[py];
      size[px]=new_size;
      size[py]=new_size;
}
```
一开始我是这样写的。
但是chatGPT说我不应该把两个根的权值都更新，只需要更新合并后的根节点即可。
虽然我觉得更新非根节点的权值似乎不影响正确的合并。
但是它觉得这没什么意义。
```c
void union_pw2(int x,int y)
{
    int px=find(x);
    int py=find(y);
    if(size[px]<size[py])//y的大
    {
        a[px]=py;
        size[py]=size[px]+size[py];
    }
    else
    {
        a[py]=px;
        size[px]=size[px]+size[py];
    }
}
```
后来我又发现了一个bug。
我没有写px=py的情况。

```c
void union_pw2(int x,int y)
{
    int px=find(x);
    int py=find(y);
    if(size[px]<size[py])//y的大
    {
        a[px]=py;
        size[py]=size[px]+size[py];
    }
    else if(size[px]>size[py])
    {
        a[py]=px;
        size[px]=size[px]+size[py];
    }
    else
    {
        return;
    }
}
```
##### 为什么权值不记录树的深度？

因为如果你记录深度，合并时无法正确维护深度。
##### 那么，如果只更新根节点记录的深度呢？每次把小树挂到大树上，大树的深度就是取它自己的深度和小数深度+1两者的最大值。

这同样不可行。因为存在着**路径压缩**。每次connected后都会让节点挂在根节点上，**树会慢慢变浅**，记录的深度失去了可靠性。

**深度在路径压缩后会失真，因此不能用于 union-by-height；  
size 或 rank 不会因路径压缩而失效，是理论上正确且稳定的权值。**

时间复杂度 O(N+M\*Log\*N)
并查集不存在O(N)复杂度的算法。









