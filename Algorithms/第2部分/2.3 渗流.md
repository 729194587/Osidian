## 渗流（Percolation）

渗流模型是 **物理、材料科学和计算机科学中的一种抽象模型**，用来研究“流体、信号或连通性通过不完全连通的网络”的问题。

- **网格结构**：通常用一个n×n的网格表示
- **站点（site）状态**：每个格点可以是
    - **开放（open）**：可以通过
    - **阻塞（blocked）**：无法通过
- **系统渗流（percolates）**：如果存在一条从顶部到底部的开放路径，则称系统渗流。

模拟过程：
-  初始化 n×n网格，所有站点阻塞
- 随机打开站点，每个站点以概率p被开放
- 每次打开后检查系统是否渗流
- 记录渗流发生时开放站点的比例 p，作为 **渗流阈值（percolation threshold）** 的估计

```c
void Percolation()//创建一个 n×n 的网格，初始时所有站点都被阻塞
{
  int n2=N*N;
  for(int i=0;i<n2;i++)
  open[i]=0;
}

void open(int row, int col)// 如果站点 (row, col) 尚未打开，则打开该站点
{
	int tmp=N*row+col;
	open[tmp]=1;
}

boolean isOpen(int row, int col)// 站点 (row, col) 是否打开？
{
   int tmp=N*row+col;
  open[tmp]=1;
}
```
`isFull(int row, int col)`判断节点是否已满，即是否与顶部节点连通。
我的想法是找各个节点的根节点，判断根节点的编号是否小于N。
```c
bool isFull(int row,int col)
{
  int tmp=N*row+col;
  int root=find(tmp);
  return root<N;
}
```
但是这样的话需要重写合并函数，保证每次合并后根节点的编号都是最小的。

chatGPT表示通常是使用了虚拟顶点。让一个虚拟顶点与顶部顶点都连通，然后判断节点是否和虚拟顶点连通即可。

但是问题来了，connected函数传入的是两个下标，需要用下标来访问数组。

所以这样的话，需要通过扩大数组来存储虚拟顶点topvirtual。

```c
int a[N+1]
int size[N+1]

bool isFull(int row,int col)
{
  int tmp=N*row+col;
  return connected(VTOP,tmp);
}
```

```c
int numberOfOpenSites() //返回已打开站点的数量
{
  int tmp=N*N;
  int count=0;
  for(int i=0;i<tmp;i++)
  {
    if(open[i])
      count++;
  }
  return count;
}

bool percolates()//系统是否开始渗流？
{
  return connected(VTOP,VBOT);
}
```
此时，又遇到了一个问题：如何判断是否渗流？
一个很好的办法是底部也创建一个虚拟的节点，与最后一行节点连通。
判断两个虚拟顶点是否连通即可。
而不是利用循环来判断虚拟顶点是否和任意底部节点连通。
那数组需要再次扩展。

```c
int a[N+2]
int size[N+2]
```

此外，我们需要考虑一下怎么把节点加入连通分量。
一个很自然的想法就是在每次Open一个节点后进行判断，因此我们需要重写一下Open函数。

```c
void Open(int row,int col)
{
   int tmp=N*row+col;
  open[tmp]=1;
  if(tmp-1>=0&&open[tmp-1]==1)
  union_pw(tmp,tmp-1);
  if(tmp+1<N*N&&open[tmp+1]==1)
  union_pw(tmp,tmp+1);
  if(tmp-N>=0&&open[tmp-N]==1)
  union_pw(tmp,tmp-N);
  if(tmp+N<=N*N&&open[tmp+N]==1)
  union_pw(tmp,tmp+N);
}
```
用当前节点的编号加加减减来到达邻居节点似乎没什么问题？
错误的，因为这可能会导致跨行！如果当前节点在每行第一个或者最后一个，就无法得到正确节点！因此我们需要用行号和列号来进行判断。

```c
void Open(int row, int col)
{
    int tmp = N*row + col;
    open[tmp] = 1;

    // 左右
    if(col > 0 && open[tmp-1])
        union_pw(tmp, tmp-1);
    if(col < N-1 && open[tmp+1])
        union_pw(tmp, tmp+1);

    // 上下
    if(row > 0 && open[tmp-N])
        union_pw(tmp, tmp-N);
    if(row < N-1 && open[tmp+N])
        union_pw(tmp, tmp+N);
}
```
main函数初始化：
```c
int main()
{
  a[VTOP]=0;
  a[VBOT]=0;
  size[VTOP]=1;
  size[VBOT]=1;
  int tmp=N*N;
  for(int i=0;i<N;i++)//将虚拟顶点与顶端节点连通。
  {
    union_pw(VTOP,i);
  }
for(int i=N*(N-1)-1;i<tmp;i++)//将虚拟低端与底部节点连通。
{
  union_pw(VBOT,i);
}
    return 0;
}
```

到这里，又出现了一个新的问题。

我把所有的顶点都直接和虚拟顶点相连通，但是它们可能甚至都没有开放！
所以应该在开放顶点的时候进行判断！
那么Open的函数就变得复杂起来了，需要判断是否已经连通，不然会重复连通。
此外，用行号来判断节点是否是顶部还是底部更加直观。
```c
void Open(int row, int col)
{
    int tmp = N*row + col;
    if(open[tmp])
      return;
    open[tmp] = 1;
    if(row==0)
    union_pw(tmp,VTOP);
    if(row==N-1)
    union_pw(tmp,VBOT);
    // 左右
    if(col > 0 && open[tmp-1])
        union_pw(tmp, tmp-1);
    if(col < N-1 && open[tmp+1])
        union_pw(tmp, tmp+1);

    // 上下
    if(row > 0 && open[tmp-N])
        union_pw(tmp, tmp-N);
    if(row < N-1 && open[tmp+N])
        union_pw(tmp, tmp+N);
}
```

实验还有一点，要求Percolation()需要传入参数n来初始化一个n\*n的网格，但是我用的N都是宏定义的。
对此，chatGPT给出的建议是采用动态内存分配,把N改为全局变量，在Percolation初始化时赋值。
我重写了一下Percolation函数：
```c
void Percolation(int n)
{
	int n2 = n*n;
	N=n;
    // 分配内存
    a = (int*)malloc(sizeof(int) * (n2 + 2));
    size = (int*)malloc(sizeof(int) * (n2 + 2));
    open = (int*)malloc(sizeof(int) * n2);
    // 初始化网格状态
    for(int i = 0; i < n2; i++)
        open[i] = 0;

    // 初始化
    for(int i = 0; i < n2 + 2; i++) {
        a[i] = i;
        size[i] = 1;
    }
    VTOP = n2;
    VBOT = n2 + 1;

}
```
最后，再添加上边界判断函数：
```c
bool isValid(int row, int col) {
    return row >= 0 && row < N && col >= 0 && col < N;
}
```
这样，可以手动初始化例子来判断是否渗流。

```c
int main()
{
int n=5;
Percolation(n);
    // 手动打开一条从上到下的通路
    Open(0, 2);
    Open(1, 2);
    Open(2, 2);
    Open(3, 2);
    Open(4, 2);

    // 打印每个格子的状态
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            printf("%d ", isOpen(i,j) ? 1 : 0);
        }
        printf("\n");
    }

    // 检查渗流
    if (percolates()) {
        printf("Percolates!\n");
    } else {
        printf("Does not percolate.\n");
    }
free(a);
free(size);
free(open);
    return 0;
}
```
![[手动示例运行结果.png]]

还有一个边界检查需要设置，在Percolation函数初始化时，需要判定n是大于0的数，如果n小于0就直接终止程序，防止后面访问野指针。我们可以把Percolation函数设置为bool型，如果n小于0直接返回false，在main函数里进行判断。
```c
bool Percolation(int n)
{
    if(n<=0)
    return false;

    int n2 = n*n;
    N=n;
    // 分配内存
    a = (int*)malloc(sizeof(int) * (n2 + 2));
    size = (int*)malloc(sizeof(int) * (n2 + 2));
    open = (int*)malloc(sizeof(int) * n2);
    // 初始化网格状态
    for(int i = 0; i < n2; i++)
        open[i] = 0;

    // 初始化并查集（包括虚拟顶点）
    for(int i = 0; i < n2 + 2; i++) {
        a[i] = i;
        size[i] = 1;
    }

    // 虚拟顶点编号
    VTOP = n2;
    VBOT = n2 + 1;
    return true;
}
```

```c
if(!Percolation(n))
{
    printf("用于初始化的n必须是整数！");
    return 0;
}
```

此时我遇到了一个意外的问题，那就是我的程序把中文输出成了乱码！

费了好大的功夫，在deepseek那找到了解决方案：
Open Workspace Settings来打开settings.json，添加如下代码：
```
    "terminal.integrated.profiles.windows": {
    "PowerShell": {
        "source": "PowerShell",
        "icon": "terminal-powershell",
        "args": ["-NoExit", "-Command", "[Console]::OutputEncoding = [System.Text.Encoding]::UTF8"]
    }
},
"terminal.integrated.defaultProfile.windows": "PowerShell"
}
```
问题解决。
似乎是因为终端还在使用老旧的GBK编码去解读中文，而不是UTF-8。
我记得之前写的时候还能正确编码中文来着。


