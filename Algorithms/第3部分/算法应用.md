### 三数和（3-SUM）问题

**给定一个包含 `N` 个整数的数组 `a[0..N-1]`，求数组中所有和为零的三元组 `(a[i], a[j], a[k])`，其中 `i < j < k`。**

- 暴力求解 

三重循环，时间O(N^3)，简单粗暴。

- 二分查找优化。
排序后用二分查找在两层循环里找第三个值。
时间O(N^2logN)

- 双指针
排序后用双指针查找第一个值的相反数。
时间O(N^2)

先快排。
```c 
void quick_sort(int* a,int start,int end)
{

    if (start >= end) 
    return;
    int left=start;
    int right=end;
    int mid=a[left];
    while(left<right)
    {
    while(left<right&&a[right]>=mid)
    right--;
    a[left]=a[right];
    while (left<right&&a[left]<=mid)
            left++;
    a[right]=a[left];
    }
    a[left]=mid;

    quick_sort(a,start,left-1);
    quick_sort(a,left+1,end);
}
```
再用双指针。
```c
int three_sum(int * a)
{
    int count=0;
    for(int i=0;i<N-2;i++)
    {
        int tmp=a[i];
        int goal=-a[i];
        int j=i+1;
        int k=N-1;
while(j<k)
{
    int sum=a[j]+a[k];
    if(sum<goal)
    j++;
    else if(sum==goal)
    {
        count++;
    int x = a[j], y = a[k];
    while (j < k && a[j] == x) j++;
    while (j < k && a[k] == y) k--;
    }
    else if(sum>goal)
    k--;
}
    }
    return count;
}
```
利用`i`和`j`两个双指针在有序的数组里进行寻找，左右逼近目标值，避免不必要的循环。

**2.一个数组由一个递增的整数序列，紧接着一个递减的整数序列组成。那么如何在数组中快速找到一个值？**
利用二分查找来确定峰值，然后在两边分别二分查找。

```c
int  bit_binary(int *a,int left,int right)
{
    while(left<right)
    {
    int mid=left+(right-left)/2;
    if(a[mid]>a[mid+1])//峰值在mid左边,或者是mid
    right=mid;
    else{//峰值在mid右边
    left=mid+1;
    }
    }
return left;
}

int main()
{
    int a[N]={0};
    int i=0;
    int j=0;
    for(i=0;i<N;i++)
    scanf("%d",&a[i]);
    int value=10;
int pos=bit_binary(a,0,N-1);

if(binary_search(value,a,0,pos)||binary_search(value,a,pos+1,N-1))
printf("找到了");
else
{
    printf("没找到");
}
    return 0;
}
```
一个问题就是边界需要判断N为1的话mid+1会越界。





