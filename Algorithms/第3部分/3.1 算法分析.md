
历史上有很多因设计更高性能算法而取得的成功案例，使得本来无法解决的问题得以解决。例如最著名的快速傅里叶变换（FFT）算法，它用于将一个信号的 n 个样本分解为周期分量。这是 DVD、JPEG 等多种应用的基础。简单的方法需要 N\*N的时间，而 FFT 只需 `O(NlogN)` 的步骤。算法性能的差异，决定了问题能否在大规模下得到解决。现代数字技术和数字媒体技术，正是依赖于这种效算法。

下面快速总结一下科学方法的核心步骤，它几百年来一直非常成功：
- 从自然现象中观察，例如程序在计算机上的运行时间；
- 基于观察结果提出假设或模型；
- 利用模型进行预测，比如预测更大问题规模或不同计算机上的运行时间；
- 通过进一步观察验证预测，并持续调整，直到模型、假设和观察结果一致。
 在科学方法中，有几个基本原则：
- 如果要运行实验，应期望他人重复实验时能得到相同结果；
- 假设必须具备可证伪性，即实验能显示假设可能错误。
最后，需要注意的是，我们研究的“自然现象”是具体的计算机，它将算法从抽象概念转化为实际物理事件——电子在计算机中高速运转。


## 3.2算法理论

#### 1. **大 `O（Big O）`** – 上界

**意思**：算法运行时间**最多不会超过某个函数的增长速度**（对大 N）。

#### 2. **大 Ω（Big Omega）** – 下界

f(n)=Ω(g(n))当且仅当存在常数 c>0 和 n0​，使得 f(n)≥c⋅g(n),∀n≥n0​ 

**意思**：算法运行时间**至少会达到某个函数的增长速度**。

#### **大 Θ（Big Theta）** – 紧确界

**意思**：算法运行时间的增长**和某个函数“同阶”**，既有上界又有下界。


对新问题 → 开发算法 → 证明下界

如果上下界存在差距 → 寻找新算法降低上界，或者尝试提高下界

非平凡下界通常很难证明，例如 Union-Find 的证明就很复杂。



Java的数组、对象的内存分布不仅仅只计算数据类型大小，而是还要包含对象头和其他的信息。

对象头是16字节。而且Java需要按8字节来对齐。