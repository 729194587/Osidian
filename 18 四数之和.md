
```c
int cmp(const void *a,const void *b)
{
    int x=*(int*)a;
    int y=*(int *)b;
    return x-y;
}
int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {
    qsort(nums,numsSize,sizeof(int),cmp);
    int i=0;
    int j=0;
    int count=0;
    int maxsize=10000;
    int **result=(int **)malloc(sizeof(int*)*maxsize);//怎么分配result
    for(int i=0;i<numsSize-3;i++)
    {
        for(j=i+1;j<numsSize-2;j++)
        {
            int goal=target-nums[i]-nums[j];
            int p=j+1;
            int q=numsSize-1;
            while(p<q)
            {
            int sum=nums[p]+nums[q];
            if(sum<goal)
            p++;
            else if(sum>goal)
            q--;
            else
            {
            result[count]=(int *)malloc(sizeof(int)*4);
            result[count][0]=nums[i];
            result[count][1]=nums[j];
            result[count][2]=nums[p];
            result[count][3]=nums[q];
            count++;
            }
            }
            if(nums[j+1]==nums[j]&&j<numsSize-3)
            j++;
*returnSize=count;
*returnColumnSizes = malloc(count * sizeof(int));
for (int k = 0; k < count; k++) {
    (*returnColumnSizes)[k] = 4;
}
        }
    }//怎么设置参数
    return result;
}
```
首先，我又忘了在末尾更新p和q，导致一直重复计入同一组解。
其次，我不会设置leetcode怎么返回双指针。
最后，去重的时候犯了错。
四数之和需要对i和j两个指针进行去重。

```c
int cmp(const void *a,const void *b)
{
    int x=*(int*)a;
    int y=*(int *)b;
    return x-y;
}
int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {

    if(numsSize<4)
    {
    *returnSize = 0;
    *returnColumnSizes = NULL;
    return NULL;
    }
    qsort(nums,numsSize,sizeof(int),cmp);
    int i=0;
    int j=0;
    int count=0;
    int maxsize=1000;
    int **result=(int **)malloc(sizeof(int*)*maxsize);//怎么分配result
    for(int i=0;i<numsSize-3;i++)
    {
        if(i>0&&nums[i-1]==nums[i])continue;//去重！！！
        for(j=i+1;j<numsSize-2;j++)
        {
            if(j>i+1&&nums[j-1]==nums[j])continue;//去重！！！
            int p=j+1;
            int q=numsSize-1;
            while(p<q)
            {
            long long sum=nums[p]+nums[q];
            if(sum+nums[i]+nums[j]<target)
            p++;
            else if(sum+nums[i]+nums[j]>target)
            q--;
            else
            {
            result[count]=(int *)malloc(sizeof(int)*4);
            result[count][0]=nums[i];
            result[count][1]=nums[j];
            result[count][2]=nums[p];
            result[count][3]=nums[q];
            count++;
            while(p < q && nums[p] == nums[p+1]) p++;
            while(p < q && nums[q] == nums[q-1]) q--;
            p++;
            q--;//跳过p和q的重复元素！！！！！
            }
            }
        }
    }
*returnSize=count;
*returnColumnSizes = malloc(count * sizeof(int));
for (int k = 0; k < count; k++) {
    (*returnColumnSizes)[k] = 4;
}//怎么设置参数
    return result;
}
```
但是我的运行时间较慢。
官方的题解一个优化是剪枝
```c
int cmp(const void *a,const void *b)
{
    int x=*(int*)a;
    int y=*(int *)b;
    return x-y;
}
int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {

    if(numsSize<4)
    {
    *returnSize = 0;
    *returnColumnSizes = NULL;
    return NULL;
    }
    qsort(nums,numsSize,sizeof(int),cmp);
    int i=0;
    int j=0;
    int count=0;
    int maxsize=10000;
    int **result=(int **)malloc(sizeof(int*)*maxsize);//怎么分配result
    for(int i=0;i<numsSize-3;i++)
    {
        if(i>0&&nums[i-1]==nums[i])continue;//去重！！！

if((long)nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;
if((long)nums[i]+nums[numsSize-3]+nums[numsSize-2]+nums[numsSize-1]<target) continue;//剪枝，看最大和最小。
        for(j=i+1;j<numsSize-2;j++)
        {
            if(j>i+1&&nums[j-1]==nums[j])continue;//去重！！！
            if((long)nums[i]+nums[j]+nums[numsSize-2]+nums[numsSize-1]<target) continue;
            if((long)nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;//剪枝！！

            int goal=target-nums[i]-nums[j];
            int p=j+1;
            int q=numsSize-1;
            while(p<q)
            {
            int sum=nums[p]+nums[q];
            if(sum<goal)
            p++;
            else if(sum>goal)
            q--;
            else
            {
            result[count]=(int *)malloc(sizeof(int)*4);
            result[count][0]=nums[i];
            result[count][1]=nums[j];
            result[count][2]=nums[p];
            result[count][3]=nums[q];
            count++;
            while(p < q && nums[p] == nums[p+1]) p++;
            while(p < q && nums[q] == nums[q-1]) q--;
            p++;
            q--;//跳过p和q的重复元素！！！！！
            }
            }
        }
    }
*returnSize=count;
*returnColumnSizes = malloc(count * sizeof(int));
for (int k = 0; k < count; k++) {
    (*returnColumnSizes)[k] = 4;
}//怎么设置参数
    return result;
}
```
通过剪枝，运行速度大幅提升。
**`returnSize`返回结果个数
**`returnColumnSizes` 是一个输出数组，表示每一行有多少列。

