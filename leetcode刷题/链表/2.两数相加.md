给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

初版代码。
```c
#include<stdio.h>
#include<stdlib.h>
  struct ListNode {
      int val;
      struct ListNode *next;
  };

struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {
    int c[100]={0};
struct ListNode* a,*p;
p=a;
int i=0;
while(l1&&l2)//两边都存在
{
    int value=(l1->val+l2->val+c[i])%10;
     c[i+1]=(l1->val+l2->val+c[i])/10;
     struct ListNode* q=(struct ListNode*)malloc(sizeof(struct ListNode*));
     q->val=0;
     q->next=NULL;
     p->next=q;
     p=q;
     free(q);
     l1=l1->next;
     l2=l2->next;
     i++;
}
while(l1)//如果l1没有加完。
{
    struct ListNode* q=(struct ListNode*)malloc(sizeof(struct ListNode*));
    q->val=c[i]+l1->val;
    q->next=NULL;
     p->next=q;
     p=q;
     free(q);
     i++;
    l1=l1->next;
}
    while(l2)//如果l2没有加完。
{
    struct ListNode* q=(struct ListNode*)malloc(sizeof(struct ListNode*));
    q->val=c[i]+l2->val;
    q->next=NULL;
     p->next=q;
     p=q;
     free(q);
     i++;
    l2=l2->next;
}
}
```
- 未初始化头节点 → `p=a;` 错误
- malloc 用了错误的大小
- malloc 后立刻 free 掉节点
- 结果值没有写入节点
- 函数没有 return
- carry 的逻辑也是不完整的

修改后的：
```c
struct ListNode dummy;  // 创建一个哑节点
dummy.val = 0;
dummy.next = NULL;
struct ListNode* p = &dummy;
int carry=0;
while(l1&&l2)//两边都存在
{
     struct ListNode* q=(struct ListNode*)malloc(sizeof(struct ListNode));
     q->val=(l1->val+l2->val+carry)%10;
     carry=(l1->val+l2->val+carry)/10;
     q->next=NULL;
     p->next=q;
     p=q;
     l1=l1->next;
     l2=l2->next;
}
while(l1)//如果l1没有加完。
{
    struct ListNode* q=(struct ListNode*)malloc(sizeof(struct ListNode));
    q->val=(carry+l1->val)%10;
    carry=(carry+l1->val)/10;
    q->next=NULL;
    p->next=q;
    p=q;
    l1=l1->next;
}
    while(l2)//如果l2没有加完。
{
    struct ListNode* q=(struct ListNode*)malloc(sizeof(struct ListNode));
    q->val=(carry+l2->val)%10;
    carry=(carry+l2->val)/10;
    q->next=NULL;
    p->next=q;
    p=q;
    l2=l2->next;
}
if(carry)
{
    struct ListNode* new_node=(struct ListNode*)malloc(sizeof(struct ListNode));
    new_node->val=carry;
    new_node->next=NULL;
    p->next=new_node;
}
return dummy.next;
```

我用了一个哑节点dummy来充当头节点，并删去了进位数组，使用一个carry就能保存进位。

似乎三个while可以简化成一个。
```c
#include<stdio.h>
#include<stdlib.h>
  struct ListNode {
      int val;
      struct ListNode *next;
  };

struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {
struct ListNode dummy;  // 创建一个哑节点
dummy.val = 0;
dummy.next = NULL;
struct ListNode* p = &dummy;
int carry=0;
while(l1||l2||carry)//统一判断。
{
    int x = (l1 ? l1->val : 0);  // 如果 l1 是 NULL，取 0
    int y = (l2 ? l2->val : 0);  // 如果 l2 是 NULL，取 0
    int sum = x + y + carry;
    carry = sum / 10;
    struct ListNode* q=(struct ListNode*)malloc(sizeof(struct ListNode));
    q->val=sum%10;
    q->next=NULL;
    p->next=q;
    p=q;
	if (l1) l1 = l1->next;
	if (l2) l2 = l2->next;
}
return dummy.next;
}
```

统一判断，在访问指针前确认是否为空。

### C++版本
```c
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}  // 构造函数初始化
};

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode dummy(0);  // 哑节点
        ListNode* p = &dummy;
        int carry = 0;

        while (l1 || l2 || carry) {
            int x = (l1 ? l1->val : 0);
            int y = (l2 ? l2->val : 0);
            int sum = x + y + carry;
            carry = sum / 10;

            p->next = new ListNode(sum % 10);
            p = p->next;

            if (l1) l1 = l1->next;
            if (l2) l2 = l2->next;
        }
        return dummy.next;
    }
};
```

似乎和C差不多，只是结构体里面多了构造方法。
