给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

排序后for循环加双指针。

初版代码：
```c
int cmp(const void *a, const void *b) {
    int x = *(int*)a;
    int y = *(int*)b;
    return x - y;
}

int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {
    qsort(nums,numsSize,sizeof(int),cmp);
    int i=0;
int n = sizeof(nums) / sizeof(nums[0]);
int max_triplets = 0;
int count=0;//记录找到的三元组数量
if (n >= 3) {
    max_triplets = n * (n - 1) * (n - 2) / 6;
}//求出最大可能三元组数量。
if(n<3)
{
    return NULL;
}
    int ** result=(int**)malloc(sizeof(int *)*max_triplets);
    for(int i=0;i<numsSize-2;i++)
    {
     int j=i+1;
     int k=numsSize-1;
     int goal=-nums[i];
     while(j<k)
     {
        if(nums[j]+nums[k]<goal)
        j++;
        else if(nums[j]+nums[k]>goal)
        k--;
        else
        {
        result[count][0]=nums[i];
        result[count][1]=nums[j];
        result[count][2]=nums[k];
        count++;
        while (j < k && nums[j] == nums[j + 1]) //跳过重复元素
            j++;
        while (j < k && nums[k] == nums[k - 1]) 
            k--;
        }
     }
     while(nums[i]==nums[i+1]&&i<numsSize)
        i++;//跳过重复元素
    }
    return result;
}
```
运行后返回的是空数组。。
然后修改了代码后，发现leetcode返回二维数组需要设置一些信息：

```c
#include<stdio.h>
#include <stdlib.h>
int cmp(const void *a, const void *b) {
    int x = *(int*)a;
    int y = *(int*)b;
    return x - y;
}

int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) 
{
    qsort(nums,numsSize,sizeof(int),cmp);
    int i=0;
int max_triplets = 0;
int count=0;//记录找到的三元组数量
if (numsSize >= 3) {
    max_triplets = numsSize * (numsSize - 1) * (numsSize - 2) / 6;
}//求出最大可能三元组数量。
if(numsSize<3)
{
    return NULL;
}
    int ** result=(int**)malloc(sizeof(int *)*max_triplets);
    for(int i=0;i<numsSize-2;i++)
    {
    if (i > 0 && nums[i] == nums[i-1]) continue;
     int j=i+1;
     int k=numsSize-1;
     int goal=-nums[i];
     while(j<k)
     {
        if(nums[j]+nums[k]<goal)
        j++;
        else if(nums[j]+nums[k]>goal)
        k--;
        else
        {
        result[count]=(int *)malloc(sizeof(int)*3);
        result[count][0]=nums[i];
        result[count][1]=nums[j];
        result[count][2]=nums[k];
        count++;
        while (j < k && nums[j] == nums[j + 1]) //跳过重复元素
            j++;
        while (j < k && nums[k] == nums[k - 1]) 
            k--;
        j++;
        k--;//需要再移动指针
        }
     }
}
*returnSize = count;
*returnColumnSizes = (int *)malloc(count * sizeof(int));
for(int t = 0; t < count; t++)
    (*returnColumnSizes)[t] = 3;   //需要设置返回信息！
return result;
}
```
而且，数组数量过大时会导致最大三元组数量过大，运行失败。
我把最大三元组数量改成了numsize^2,通过了。
但是运行所需时间不是最优的，超过了57.2%,空间超过了80.52%。

看了下最优代码，好像是用了类似哈希表的方法快速查找第三个数：

```c
int cmp(const void* a, const void* b){
    return *(int*)a - *(int*)b;
}

int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    qsort(nums, numsSize, sizeof(int), cmp);
    int **ans = malloc(fmin(numsSize * sqrt(numsSize), 18000) * sizeof(int*));    
    int tabsize = abs(nums[0] * 2) + 1;
    bool tab[tabsize];//用于快速查找第三个数
    memset(tab, false, tabsize);
    int cnt = 0;
    int temp = 0;
    int lastx = 0, lasty = 0;

    for (int i = 0; i < tabsize; i++){
        for (lastx = lasty; lastx < numsSize; lastx++){
            if (nums[lastx] == i){
                tab[i] = true;
                while (++lastx < numsSize && nums[lastx-1] == nums[lastx]);
                lasty = lastx;
                break;
            } else if (nums[lastx] > i) break;
        }  
    }
    lastx = lasty = -1e5 - 1;
    for (int x = 0; x < numsSize; x++){
        if (lastx == nums[x]) continue;
        for (int y = x + 1; y < numsSize - 1; y++){
            if (lasty == nums[y] && lastx == nums[x]) continue;
            temp = -(nums[x] + nums[y]);
            if (temp < nums[y]) break;
            if (tab[temp] && temp >= nums[y+1]){
                int *l = malloc(3 * sizeof(int));
                l[0] = nums[x];
                l[1] = nums[y];
                l[2] = temp;
                ans[cnt++] = l;
                lastx = nums[x];
                lasty = nums[y];
                //printf("%3d |%3d %3d %3d\n", cnt, l[0], l[1], l[2]);
            }
        }
    }
    *returnSize = cnt;
    *returnColumnSizes = malloc(sizeof(int) * cnt);
    for(int i = 0; i < cnt; i++){
        (*returnColumnSizes)[i] = 3;
    }
    return ans;
}
```
真复杂。
就是用tab来记录数是否存在，方便快速查第三个数。

