
整数数组的一个 **排列**  就是将其所有成员以序列或线性顺序排列。

- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须 **原地修改，只允许使用额外常数空间。
```c
void nextPermutation(int* nums, int numsSize) {
    if(numsSize==1)//边界条件
   return;

    int i=numsSize-2;
    for(;i>=0;i--)
    {
        if(nums[i+1]>nums[i])//从后往前找一个升序的数nums[i]
        break;
    }
    if(i<0)//从大到小排列
    {
            int l=i+1;
            int r=numsSize-1;
           while(l<r)
    {
        int tmp=nums[l];
        nums[l]=nums[r];
        nums[r]=tmp;
        l++;
        r--;
    } 
    return;
    }
    int j=0;
    int swap_pos=0;
    for(j=numsSize-1;j>i;j--)//从后往前找大于nums[i]的最小值。
    {
        if(nums[j]>nums[i])//i后面是降序，找第一个大于nums[i]的
        {
        swap_pos=j;
        break;
        }
    }
    int tmp=nums[i];
    nums[i]=nums[swap_pos];
    nums[swap_pos]=tmp;//交换保证增量最小。

    //反转i后面的数组
    int l=i+1;
    int r=numsSize-1;
    while(l<r)
    {
        int tmp=nums[l];
        nums[l]=nums[r];
        nums[r]=tmp;
        l++;
        r--;
    }
}
```
这题我根本不会写，照着chatgpt的提示步骤一步一步写的，还写错了好多地方。
再次感觉自己不适合整算法这玩意。

下面是chatgpt写的：
```c
void nextPermutation(int* nums, int numsSize) {
    if (numsSize <= 1) return;  // 1个元素或空数组直接返回

    // 1. 找下降点 i
    int i = numsSize - 2;
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }

    // 2. 如果 i>=0，找到 i 后面比 nums[i] 大的最小值 j，交换
    if (i >= 0) {
        int j = numsSize - 1;
        while (nums[j] <= nums[i]) {
            j--;
        }
        // 交换 nums[i] 和 nums[j]
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }

    // 3. 反转 i+1 到末尾
    int l = i + 1, r = numsSize - 1;
    while (l < r) {
        int tmp = nums[l];
        nums[l] = nums[r];
        nums[r] = tmp;
        l++;
        r--;
    }
}
```

写代码时犯了很多错，忘了return、越界访问、甚至if判断语句都能写错。。

核心是 **找到顺序规律、最小增量、反向处理**。
- **从后向前扫描**，找第一个不符合递增/递减的点（下降点/上升点）
- **确定需要交换的元素**（最小增量）
- **交换**
- **反转尾部**，保证尾部升序或降序
- **特殊情况**（整个序列是降序 → 最大/最小排列）

## 1️⃣ **明确思路再动手**

很多错误都是因为**逻辑没完全理清**就写代码：
- **先用自然语言或伪代码描述算法**
    - 例如 nextPermutation：
        1. 从尾部找下降点 i
        2. 找 j > i 且 nums[j] > nums[i]
        3. 交换 nums[i] 和 nums[j]
        4. 反转 i+1 到末尾
- **画例子**（手动跟踪一两组小数据）
    - 可以发现 i、j、交换、反转的具体变化
    - 手动模拟能提前发现越界或逻辑问题
> 结论：**脑子里先理顺再写代码，减少边界和索引错误**。