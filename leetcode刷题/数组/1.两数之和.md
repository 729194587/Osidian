给定一个整数数组 `nums` 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。
你可以按任意顺序返回答案。

我写的C版本：
```c
typedef struct Num
{
    int value;
    int index;
} Num;

int cmp(const void* a, const void* b) {
    Num* x = (Num*)a;
    Num* y = (Num*)b;
    return x->value - y->value; // 按 val 升序
}

int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    Num *a=(Num*)malloc(sizeof(Num)*numsSize);
    for(int i=0;i<numsSize;i++)
    {
        a[i].index=i;
        a[i].value=nums[i];
    }
    qsort(a,numsSize,sizeof(Num),cmp);
    int i=0,j=numsSize-1;
    while(i<j)
    {
    int sum=a[i].value+a[j].value;
        if(sum<target)
        i++;
        else if(sum>target)
        j--;
        else if(sum==target)
        {
            int min=a[i].index<a[j].index? a[i].index:a[j].index;
            int max=a[i].index+a[j].index-min;
            int* res = malloc(2*sizeof(int));
            *returnSize = 2;
            res[0] = min;
            res[1] = max;
            free(a);
            return res;
        }
    }  
*returnSize = 0;
free(a);
return NULL;
}
```

我一开始写的快排加双指针，但是chatGPT突然中风，把我正确的快排代码说成错误的，和它掰扯了好久才让它意识到自己错了。

然后就是需要返回下标，返回下标，返回下标。
我发现这样的话很麻烦，还得存索引。
于是只能用结构体来存。
leetcode还要求返回一个数组指针，并且最后无解的话必须返回NULL，不然就编译出错。

题目要求可以按任意顺序返回答案，那判断下标大小就不需要了。

我问了下GPT，C++怎么写这道题：
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        vector<pair<int, int>> a; // pair<value, index>
        for (int i = 0; i < n; i++) {
            a.push_back({nums[i], i});
        }

        sort(a.begin(), a.end()); // 按 value 排序

        int i = 0, j = n - 1;
        while (i < j) {
            int sum = a[i].first + a[j].first;
            if (sum < target) i++;
            else if (sum > target) j--;
            else return {a[i].second, a[j].second}; // 返回原索引
        }
        return {};
    }
};
```
C++采用vector来整数组和结构体
它返回类型也是，`vector<int>`
然后用pair来声明了一个类似于C里面struct的玩意，存值和索引。
而且直接用sort就能对这个进行排序。不过参数是a.begin()和a.end()，有点奇怪。
chatgpt说

`a.begin()` → vector 第一个元素的迭代器
`a.end()` → vector 最后一个元素的下一个位置的迭代器
**`sort(a.begin(), a.end())`;
就相当于告诉 sort：把整个 vector 的元素从头到尾排序。**

对于 `pair<int,int>`，C++ 默认的 `<` 比较规则是 **先比 `first`，再比 `second`**
所以会先比value。

return {a[i].second, a[j].second}  用来返回一个容器或者数组。


此外，C++还能用哈希表。

```c
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> mp; // key: 数值，value: 索引
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (mp.count(complement)) { // 如果补数已经出现过
            return {mp[complement], i}; // 返回补数索引和当前索引
        }
        mp[nums[i]] = i; // 否则把当前数和索引存进哈希表
    }
    return {}; // 如果没找到
}
```

`unordered_map<int, int> mp;`声明了一个哈希表mp，有两个元素。

这确实方便，直接遍历一次，如果当前元素相对于target的补数在哈希表里，直接返回，如果不在，就把当前元素存入哈希表。
