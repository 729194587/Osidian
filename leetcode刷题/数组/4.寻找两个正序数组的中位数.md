
给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。
算法的时间复杂度应该为 `O(log (m+n))` 。

我第一次是肯定写不出这道题的，只知道要用二分查找。

拷打了chatgpt好久才让它给我讲懂思路。

因为中位数在两个数组合并后位于左半数组的最大或者左半最大和右半最小的平均，对m和n两个数组较短的数组进行划分，再根据下标找到另一个数组的左半部分，m的左半和n的左半是整个左半数组，找这整个左半数组的最大值，然后再和另外的右半数组的最小值比较，根据判断条件来决定是继续划分还是算中位数。

但是，知道了思路后，我还是不知道代码怎么写。。。
我开始感觉我有点不适合干这行。

问了chatgpt思路。
```c
选短数组 nums1
imin=0, imax=nums1Size
while imin <= imax:
    i = (imin+imax)/2
    j = (total+1)/2 - i
    计算 left1, right1, left2, right2
    if 划分正确:
        返回中位数
    else if left1 > right2:
        缩小 i
    else:
        增大 i
```

然后实现了第一版代码：
```c
int max(int x,int y)
{
    return x>y? x:y;
}
int min(int x,int y)
{
    return x<y? x:y;
}
double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {
    if(nums1Size<nums2Size)
    {
        int imin=0,imax=nums1Size;
        while(imin<=imax)
        {
            int i=(imin+imax)/2;
            int j=(nums1Size+nums2Size+1)/2-i;
            int left1=nums1[i-1];
            int left2=nums2[j-1];
            int right1=nums1[i];
            int right2=nums2[j];
            int leftmax=max(left1,left2);
            int rightmin=min(right1,right2);
            if(leftmax<=rightmin)//找到中位数
            {
                if((nums1Size+nums2Size)%2)//奇数
                return leftmax;
                else
                return ((double)leftmax+rightmin)/2;
            }else
            {
                if(left1>right2)//左半划分的太大
                imax--;
                else
                imin++;
            }
        }
    }
}
```
- ❌ i/j 越界未处理
- ❌ 错误的二分查找更新逻辑
- ❌ 未处理 nums1Size ≥ nums2Size
- ❌ leftmax/rightmin 逻辑不等价
- ❌ 多处潜在数组访问越界

```c
double findMedianSortedArrays(int* A, int m, int* B, int n) {
    if (m > n)  // 保证 A 是较短的数组
        return findMedianSortedArrays(B, n, A, m);

    int imin = 0, imax = m, half = (m + n + 1) / 2;
    while (imin <= imax) {
        int i = (imin + imax) / 2;
        int j = half - i;

        int leftA  = (i == 0 ? INT_MIN : A[i - 1]);
        int rightA = (i == m ? INT_MAX : A[i]);//越界处理
        int leftB  = (j == 0 ? INT_MIN : B[j - 1]);
        int rightB = (j == n ? INT_MAX : B[j]);

        if (leftA <= rightB && leftB <= rightA) {
            if ((m + n) % 2 == 1)
                return (double) (leftA > leftB ? leftA : leftB);
            return ((double)(leftA > leftB ? leftA : leftB) +
                    (double)(rightA < rightB ? rightA : rightB)) / 2;
        }
        else if (leftA > rightB)
            imax = i - 1;
        else
            imin = i + 1;
    }
    return 0.0;
}
```

使用`if (leftA <= rightB && leftB <= rightA)`来比较左边最大值和右边最小值的大小。
~~leftmax并不是左边数组整体最大值。只有在划分正确的时候，leftmax才能代表左边最大值。~~
哦，等等。
我和chatgpt掰扯了好久，它才说可以用leftmax<=rightmin来判断是否要调整i值。
原因是我发现它在解释为什么用`if (leftA <= rightB && leftB <= rightA)`的时候，说这是用来判断划分后左边数组最大值和右边最小值的，而这用leftmax也可以啊。

这个傻B居然一直以为我要在leftmax>rightmin时直接就调整i值。
怎么可能？一个条件分支直接判断i向小调整还是向大调整？

不过`if (leftA <= rightB && leftB <= rightA)`可以在调整i值时判断的更方便。



