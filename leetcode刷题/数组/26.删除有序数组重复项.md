
给你一个 **非严格递增排列** 的数组 `nums` ，请你 **原地删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k`。去重后，返回唯一元素的数量 `k`。

`nums` 的前 `k` 个元素应包含 **排序后** 的唯一数字。下标 `k - 1` 之后的剩余元素可以忽略。

```c
#include<stdlib.h>
int removeDuplicates(int* nums, int numsSize) {
 int count=1;
 int i=0;
 int j=1;
 while(i<numsSize-1&&j<numsSize)
 {
    while(nums[j]==nums[i]&&j<numsSize-1)
    j++;
    nums[count]=nums[j];
    i=j;
    count++;
 }   
 return count;
}
```
我使用了两个指针，但这会让问题复杂化，并且容易越界访问。
其实正确的答案很简单。
```c
int removeDuplicates(int* nums, int numsSize) {
    if(numsSize==0) return 0;
 int count=1;
 int i=0;
for(i=1;i<numsSize;i++)
{
    if(nums[i-1]!=nums[i])
    {
    nums[count]=nums[i];
    count++;
    }
}
 return count;
}
```