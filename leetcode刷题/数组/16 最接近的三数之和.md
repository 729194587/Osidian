
给你一个长度为 `n` 的整数数组 `nums` 和 一个目标值 `target`。请你从 `nums` 中选出三个整数，使它们的和与 `target` 最接近。
返回这三个数的和。
假定每组输入只存在恰好一个解。
```c
int distance(int x,int y)
{
    if(x<y)
    return y-x;
    else
    return x-y;
}
int cmp(const void *a, const void *b) {
    int x = *(int*)a;
    int y = *(int*)b;
    return x - y;
}

int threeSumClosest(int* nums, int numsSize, int target) {
    qsort(nums,numsSize,sizeof(int),cmp);
    int ans=-10000;
    int dis=100000;
    //int ans = nums[0] + nums[1] + nums[2]; // 初始为第一个三数之和
	//int dis = distance(target, ans);       // 初始差值

    int i=0;
    for(i=0;i<numsSize-2;i++)
    {
    //这里不需要根据nums[i]来break.
        int j=i+1;
        int k=numsSize-1;
        int goal=target-nums[i];
        while(j<k)
        {
        int min=distance(target,nums[i]+nums[j]+nums[k]);
        if(min<dis)
        {
        dis=min;
        ans=nums[i]+nums[j]+nums[k];
        }
   
        if(nums[j]+nums[k]<goal)
                j++;
        else if(nums[j]+nums[k]>goal)
                k--;
        else 
        return target;
        }
    }
    return ans;//返回的不是距离
}
```

绝对值函数abs已经有了。`abs(target-sum)`
